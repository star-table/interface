// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: automation.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on GetWorkflowsByAppReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetWorkflowsByAppReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetWorkflowsByAppReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetWorkflowsByAppReqMultiError, or nil if none found.
func (m *GetWorkflowsByAppReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetWorkflowsByAppReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetAppId()); l < 1 || l > 20 {
		err := GetWorkflowsByAppReqValidationError{
			field:  "AppId",
			reason: "value length must be between 1 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetWorkflowsByAppReqMultiError(errors)
	}

	return nil
}

// GetWorkflowsByAppReqMultiError is an error wrapping multiple validation
// errors returned by GetWorkflowsByAppReq.ValidateAll() if the designated
// constraints aren't met.
type GetWorkflowsByAppReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetWorkflowsByAppReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetWorkflowsByAppReqMultiError) AllErrors() []error { return m }

// GetWorkflowsByAppReqValidationError is the validation error returned by
// GetWorkflowsByAppReq.Validate if the designated constraints aren't met.
type GetWorkflowsByAppReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetWorkflowsByAppReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetWorkflowsByAppReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetWorkflowsByAppReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetWorkflowsByAppReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetWorkflowsByAppReqValidationError) ErrorName() string {
	return "GetWorkflowsByAppReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetWorkflowsByAppReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetWorkflowsByAppReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetWorkflowsByAppReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetWorkflowsByAppReqValidationError{}

// Validate checks the field values on GetWorkflowsByAppReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetWorkflowsByAppReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetWorkflowsByAppReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetWorkflowsByAppReplyMultiError, or nil if none found.
func (m *GetWorkflowsByAppReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetWorkflowsByAppReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetWorkflows() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetWorkflowsByAppReplyValidationError{
						field:  fmt.Sprintf("Workflows[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetWorkflowsByAppReplyValidationError{
						field:  fmt.Sprintf("Workflows[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetWorkflowsByAppReplyValidationError{
					field:  fmt.Sprintf("Workflows[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetWorkflowsByAppReplyMultiError(errors)
	}

	return nil
}

// GetWorkflowsByAppReplyMultiError is an error wrapping multiple validation
// errors returned by GetWorkflowsByAppReply.ValidateAll() if the designated
// constraints aren't met.
type GetWorkflowsByAppReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetWorkflowsByAppReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetWorkflowsByAppReplyMultiError) AllErrors() []error { return m }

// GetWorkflowsByAppReplyValidationError is the validation error returned by
// GetWorkflowsByAppReply.Validate if the designated constraints aren't met.
type GetWorkflowsByAppReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetWorkflowsByAppReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetWorkflowsByAppReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetWorkflowsByAppReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetWorkflowsByAppReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetWorkflowsByAppReplyValidationError) ErrorName() string {
	return "GetWorkflowsByAppReplyValidationError"
}

// Error satisfies the builtin error interface
func (e GetWorkflowsByAppReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetWorkflowsByAppReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetWorkflowsByAppReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetWorkflowsByAppReplyValidationError{}

// Validate checks the field values on GetWorkflowReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetWorkflowReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetWorkflowReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetWorkflowReqMultiError,
// or nil if none found.
func (m *GetWorkflowReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetWorkflowReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 1 || l > 20 {
		err := GetWorkflowReqValidationError{
			field:  "Id",
			reason: "value length must be between 1 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetWorkflowReqMultiError(errors)
	}

	return nil
}

// GetWorkflowReqMultiError is an error wrapping multiple validation errors
// returned by GetWorkflowReq.ValidateAll() if the designated constraints
// aren't met.
type GetWorkflowReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetWorkflowReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetWorkflowReqMultiError) AllErrors() []error { return m }

// GetWorkflowReqValidationError is the validation error returned by
// GetWorkflowReq.Validate if the designated constraints aren't met.
type GetWorkflowReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetWorkflowReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetWorkflowReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetWorkflowReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetWorkflowReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetWorkflowReqValidationError) ErrorName() string { return "GetWorkflowReqValidationError" }

// Error satisfies the builtin error interface
func (e GetWorkflowReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetWorkflowReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetWorkflowReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetWorkflowReqValidationError{}

// Validate checks the field values on GetWorkflowReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetWorkflowReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetWorkflowReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetWorkflowReplyMultiError, or nil if none found.
func (m *GetWorkflowReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetWorkflowReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetWorkflow()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetWorkflowReplyValidationError{
					field:  "Workflow",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetWorkflowReplyValidationError{
					field:  "Workflow",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWorkflow()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetWorkflowReplyValidationError{
				field:  "Workflow",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetWorkflowReplyMultiError(errors)
	}

	return nil
}

// GetWorkflowReplyMultiError is an error wrapping multiple validation errors
// returned by GetWorkflowReply.ValidateAll() if the designated constraints
// aren't met.
type GetWorkflowReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetWorkflowReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetWorkflowReplyMultiError) AllErrors() []error { return m }

// GetWorkflowReplyValidationError is the validation error returned by
// GetWorkflowReply.Validate if the designated constraints aren't met.
type GetWorkflowReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetWorkflowReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetWorkflowReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetWorkflowReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetWorkflowReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetWorkflowReplyValidationError) ErrorName() string { return "GetWorkflowReplyValidationError" }

// Error satisfies the builtin error interface
func (e GetWorkflowReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetWorkflowReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetWorkflowReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetWorkflowReplyValidationError{}

// Validate checks the field values on SaveWorkflowMetaReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SaveWorkflowMetaReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SaveWorkflowMetaReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SaveWorkflowMetaReqMultiError, or nil if none found.
func (m *SaveWorkflowMetaReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SaveWorkflowMetaReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 1 || l > 20 {
		err := SaveWorkflowMetaReqValidationError{
			field:  "Id",
			reason: "value length must be between 1 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 0 || l > 128 {
		err := SaveWorkflowMetaReqValidationError{
			field:  "Name",
			reason: "value length must be between 0 and 128 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDesc()); l < 0 || l > 1024 {
		err := SaveWorkflowMetaReqValidationError{
			field:  "Desc",
			reason: "value length must be between 0 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return SaveWorkflowMetaReqMultiError(errors)
	}

	return nil
}

// SaveWorkflowMetaReqMultiError is an error wrapping multiple validation
// errors returned by SaveWorkflowMetaReq.ValidateAll() if the designated
// constraints aren't met.
type SaveWorkflowMetaReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SaveWorkflowMetaReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SaveWorkflowMetaReqMultiError) AllErrors() []error { return m }

// SaveWorkflowMetaReqValidationError is the validation error returned by
// SaveWorkflowMetaReq.Validate if the designated constraints aren't met.
type SaveWorkflowMetaReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SaveWorkflowMetaReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SaveWorkflowMetaReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SaveWorkflowMetaReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SaveWorkflowMetaReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SaveWorkflowMetaReqValidationError) ErrorName() string {
	return "SaveWorkflowMetaReqValidationError"
}

// Error satisfies the builtin error interface
func (e SaveWorkflowMetaReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSaveWorkflowMetaReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SaveWorkflowMetaReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SaveWorkflowMetaReqValidationError{}

// Validate checks the field values on SaveWorkflowMetaReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SaveWorkflowMetaReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SaveWorkflowMetaReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SaveWorkflowMetaReplyMultiError, or nil if none found.
func (m *SaveWorkflowMetaReply) ValidateAll() error {
	return m.validate(true)
}

func (m *SaveWorkflowMetaReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetWorkflow()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SaveWorkflowMetaReplyValidationError{
					field:  "Workflow",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SaveWorkflowMetaReplyValidationError{
					field:  "Workflow",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWorkflow()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SaveWorkflowMetaReplyValidationError{
				field:  "Workflow",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SaveWorkflowMetaReplyMultiError(errors)
	}

	return nil
}

// SaveWorkflowMetaReplyMultiError is an error wrapping multiple validation
// errors returned by SaveWorkflowMetaReply.ValidateAll() if the designated
// constraints aren't met.
type SaveWorkflowMetaReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SaveWorkflowMetaReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SaveWorkflowMetaReplyMultiError) AllErrors() []error { return m }

// SaveWorkflowMetaReplyValidationError is the validation error returned by
// SaveWorkflowMetaReply.Validate if the designated constraints aren't met.
type SaveWorkflowMetaReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SaveWorkflowMetaReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SaveWorkflowMetaReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SaveWorkflowMetaReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SaveWorkflowMetaReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SaveWorkflowMetaReplyValidationError) ErrorName() string {
	return "SaveWorkflowMetaReplyValidationError"
}

// Error satisfies the builtin error interface
func (e SaveWorkflowMetaReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSaveWorkflowMetaReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SaveWorkflowMetaReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SaveWorkflowMetaReplyValidationError{}

// Validate checks the field values on SaveWorkflowReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SaveWorkflowReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SaveWorkflowReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SaveWorkflowReqMultiError, or nil if none found.
func (m *SaveWorkflowReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SaveWorkflowReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetAppId()); l < 1 || l > 20 {
		err := SaveWorkflowReqValidationError{
			field:  "AppId",
			reason: "value length must be between 1 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetId()); l < 0 || l > 20 {
		err := SaveWorkflowReqValidationError{
			field:  "Id",
			reason: "value length must be between 0 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetInput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SaveWorkflowReqValidationError{
					field:  "Input",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SaveWorkflowReqValidationError{
					field:  "Input",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SaveWorkflowReqValidationError{
				field:  "Input",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Activate

	if len(errors) > 0 {
		return SaveWorkflowReqMultiError(errors)
	}

	return nil
}

// SaveWorkflowReqMultiError is an error wrapping multiple validation errors
// returned by SaveWorkflowReq.ValidateAll() if the designated constraints
// aren't met.
type SaveWorkflowReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SaveWorkflowReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SaveWorkflowReqMultiError) AllErrors() []error { return m }

// SaveWorkflowReqValidationError is the validation error returned by
// SaveWorkflowReq.Validate if the designated constraints aren't met.
type SaveWorkflowReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SaveWorkflowReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SaveWorkflowReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SaveWorkflowReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SaveWorkflowReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SaveWorkflowReqValidationError) ErrorName() string { return "SaveWorkflowReqValidationError" }

// Error satisfies the builtin error interface
func (e SaveWorkflowReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSaveWorkflowReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SaveWorkflowReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SaveWorkflowReqValidationError{}

// Validate checks the field values on SaveWorkflowReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SaveWorkflowReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SaveWorkflowReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SaveWorkflowReplyMultiError, or nil if none found.
func (m *SaveWorkflowReply) ValidateAll() error {
	return m.validate(true)
}

func (m *SaveWorkflowReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetWorkflow()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SaveWorkflowReplyValidationError{
					field:  "Workflow",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SaveWorkflowReplyValidationError{
					field:  "Workflow",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWorkflow()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SaveWorkflowReplyValidationError{
				field:  "Workflow",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetActivateErrors() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SaveWorkflowReplyValidationError{
						field:  fmt.Sprintf("ActivateErrors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SaveWorkflowReplyValidationError{
						field:  fmt.Sprintf("ActivateErrors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SaveWorkflowReplyValidationError{
					field:  fmt.Sprintf("ActivateErrors[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SaveWorkflowReplyMultiError(errors)
	}

	return nil
}

// SaveWorkflowReplyMultiError is an error wrapping multiple validation errors
// returned by SaveWorkflowReply.ValidateAll() if the designated constraints
// aren't met.
type SaveWorkflowReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SaveWorkflowReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SaveWorkflowReplyMultiError) AllErrors() []error { return m }

// SaveWorkflowReplyValidationError is the validation error returned by
// SaveWorkflowReply.Validate if the designated constraints aren't met.
type SaveWorkflowReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SaveWorkflowReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SaveWorkflowReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SaveWorkflowReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SaveWorkflowReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SaveWorkflowReplyValidationError) ErrorName() string {
	return "SaveWorkflowReplyValidationError"
}

// Error satisfies the builtin error interface
func (e SaveWorkflowReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSaveWorkflowReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SaveWorkflowReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SaveWorkflowReplyValidationError{}

// Validate checks the field values on DeleteWorkflowReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteWorkflowReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteWorkflowReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteWorkflowReqMultiError, or nil if none found.
func (m *DeleteWorkflowReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteWorkflowReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 1 || l > 20 {
		err := DeleteWorkflowReqValidationError{
			field:  "Id",
			reason: "value length must be between 1 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteWorkflowReqMultiError(errors)
	}

	return nil
}

// DeleteWorkflowReqMultiError is an error wrapping multiple validation errors
// returned by DeleteWorkflowReq.ValidateAll() if the designated constraints
// aren't met.
type DeleteWorkflowReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteWorkflowReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteWorkflowReqMultiError) AllErrors() []error { return m }

// DeleteWorkflowReqValidationError is the validation error returned by
// DeleteWorkflowReq.Validate if the designated constraints aren't met.
type DeleteWorkflowReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteWorkflowReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteWorkflowReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteWorkflowReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteWorkflowReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteWorkflowReqValidationError) ErrorName() string {
	return "DeleteWorkflowReqValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteWorkflowReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteWorkflowReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteWorkflowReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteWorkflowReqValidationError{}

// Validate checks the field values on DeleteWorkflowReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteWorkflowReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteWorkflowReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteWorkflowReplyMultiError, or nil if none found.
func (m *DeleteWorkflowReply) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteWorkflowReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteWorkflowReplyMultiError(errors)
	}

	return nil
}

// DeleteWorkflowReplyMultiError is an error wrapping multiple validation
// errors returned by DeleteWorkflowReply.ValidateAll() if the designated
// constraints aren't met.
type DeleteWorkflowReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteWorkflowReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteWorkflowReplyMultiError) AllErrors() []error { return m }

// DeleteWorkflowReplyValidationError is the validation error returned by
// DeleteWorkflowReply.Validate if the designated constraints aren't met.
type DeleteWorkflowReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteWorkflowReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteWorkflowReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteWorkflowReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteWorkflowReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteWorkflowReplyValidationError) ErrorName() string {
	return "DeleteWorkflowReplyValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteWorkflowReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteWorkflowReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteWorkflowReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteWorkflowReplyValidationError{}

// Validate checks the field values on ActivateWorkflowReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ActivateWorkflowReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ActivateWorkflowReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ActivateWorkflowReqMultiError, or nil if none found.
func (m *ActivateWorkflowReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ActivateWorkflowReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 1 || l > 20 {
		err := ActivateWorkflowReqValidationError{
			field:  "Id",
			reason: "value length must be between 1 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ActivateWorkflowReqMultiError(errors)
	}

	return nil
}

// ActivateWorkflowReqMultiError is an error wrapping multiple validation
// errors returned by ActivateWorkflowReq.ValidateAll() if the designated
// constraints aren't met.
type ActivateWorkflowReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ActivateWorkflowReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ActivateWorkflowReqMultiError) AllErrors() []error { return m }

// ActivateWorkflowReqValidationError is the validation error returned by
// ActivateWorkflowReq.Validate if the designated constraints aren't met.
type ActivateWorkflowReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ActivateWorkflowReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ActivateWorkflowReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ActivateWorkflowReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ActivateWorkflowReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ActivateWorkflowReqValidationError) ErrorName() string {
	return "ActivateWorkflowReqValidationError"
}

// Error satisfies the builtin error interface
func (e ActivateWorkflowReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sActivateWorkflowReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ActivateWorkflowReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ActivateWorkflowReqValidationError{}

// Validate checks the field values on ActivateWorkflowReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ActivateWorkflowReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ActivateWorkflowReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ActivateWorkflowReplyMultiError, or nil if none found.
func (m *ActivateWorkflowReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ActivateWorkflowReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetActivateErrors() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActivateWorkflowReplyValidationError{
						field:  fmt.Sprintf("ActivateErrors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActivateWorkflowReplyValidationError{
						field:  fmt.Sprintf("ActivateErrors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActivateWorkflowReplyValidationError{
					field:  fmt.Sprintf("ActivateErrors[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ActivateWorkflowReplyMultiError(errors)
	}

	return nil
}

// ActivateWorkflowReplyMultiError is an error wrapping multiple validation
// errors returned by ActivateWorkflowReply.ValidateAll() if the designated
// constraints aren't met.
type ActivateWorkflowReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ActivateWorkflowReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ActivateWorkflowReplyMultiError) AllErrors() []error { return m }

// ActivateWorkflowReplyValidationError is the validation error returned by
// ActivateWorkflowReply.Validate if the designated constraints aren't met.
type ActivateWorkflowReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ActivateWorkflowReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ActivateWorkflowReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ActivateWorkflowReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ActivateWorkflowReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ActivateWorkflowReplyValidationError) ErrorName() string {
	return "ActivateWorkflowReplyValidationError"
}

// Error satisfies the builtin error interface
func (e ActivateWorkflowReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sActivateWorkflowReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ActivateWorkflowReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ActivateWorkflowReplyValidationError{}

// Validate checks the field values on DeactivateWorkflowReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeactivateWorkflowReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeactivateWorkflowReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeactivateWorkflowReqMultiError, or nil if none found.
func (m *DeactivateWorkflowReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeactivateWorkflowReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 1 || l > 20 {
		err := DeactivateWorkflowReqValidationError{
			field:  "Id",
			reason: "value length must be between 1 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeactivateWorkflowReqMultiError(errors)
	}

	return nil
}

// DeactivateWorkflowReqMultiError is an error wrapping multiple validation
// errors returned by DeactivateWorkflowReq.ValidateAll() if the designated
// constraints aren't met.
type DeactivateWorkflowReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeactivateWorkflowReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeactivateWorkflowReqMultiError) AllErrors() []error { return m }

// DeactivateWorkflowReqValidationError is the validation error returned by
// DeactivateWorkflowReq.Validate if the designated constraints aren't met.
type DeactivateWorkflowReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeactivateWorkflowReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeactivateWorkflowReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeactivateWorkflowReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeactivateWorkflowReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeactivateWorkflowReqValidationError) ErrorName() string {
	return "DeactivateWorkflowReqValidationError"
}

// Error satisfies the builtin error interface
func (e DeactivateWorkflowReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeactivateWorkflowReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeactivateWorkflowReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeactivateWorkflowReqValidationError{}

// Validate checks the field values on DeactivateWorkflowReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeactivateWorkflowReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeactivateWorkflowReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeactivateWorkflowReplyMultiError, or nil if none found.
func (m *DeactivateWorkflowReply) ValidateAll() error {
	return m.validate(true)
}

func (m *DeactivateWorkflowReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeactivateWorkflowReplyMultiError(errors)
	}

	return nil
}

// DeactivateWorkflowReplyMultiError is an error wrapping multiple validation
// errors returned by DeactivateWorkflowReply.ValidateAll() if the designated
// constraints aren't met.
type DeactivateWorkflowReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeactivateWorkflowReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeactivateWorkflowReplyMultiError) AllErrors() []error { return m }

// DeactivateWorkflowReplyValidationError is the validation error returned by
// DeactivateWorkflowReply.Validate if the designated constraints aren't met.
type DeactivateWorkflowReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeactivateWorkflowReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeactivateWorkflowReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeactivateWorkflowReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeactivateWorkflowReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeactivateWorkflowReplyValidationError) ErrorName() string {
	return "DeactivateWorkflowReplyValidationError"
}

// Error satisfies the builtin error interface
func (e DeactivateWorkflowReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeactivateWorkflowReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeactivateWorkflowReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeactivateWorkflowReplyValidationError{}

// Validate checks the field values on GetExecutionsReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetExecutionsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetExecutionsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetExecutionsReqMultiError, or nil if none found.
func (m *GetExecutionsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetExecutionsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetWorkflowId()); l < 1 || l > 20 {
		err := GetExecutionsReqValidationError{
			field:  "WorkflowId",
			reason: "value length must be between 1 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLimit() <= 0 {
		err := GetExecutionsReqValidationError{
			field:  "Limit",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Cursor

	if len(errors) > 0 {
		return GetExecutionsReqMultiError(errors)
	}

	return nil
}

// GetExecutionsReqMultiError is an error wrapping multiple validation errors
// returned by GetExecutionsReq.ValidateAll() if the designated constraints
// aren't met.
type GetExecutionsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetExecutionsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetExecutionsReqMultiError) AllErrors() []error { return m }

// GetExecutionsReqValidationError is the validation error returned by
// GetExecutionsReq.Validate if the designated constraints aren't met.
type GetExecutionsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetExecutionsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetExecutionsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetExecutionsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetExecutionsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetExecutionsReqValidationError) ErrorName() string { return "GetExecutionsReqValidationError" }

// Error satisfies the builtin error interface
func (e GetExecutionsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetExecutionsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetExecutionsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetExecutionsReqValidationError{}

// Validate checks the field values on GetExecutionsReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetExecutionsReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetExecutionsReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetExecutionsReplyMultiError, or nil if none found.
func (m *GetExecutionsReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetExecutionsReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetExecutions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetExecutionsReplyValidationError{
						field:  fmt.Sprintf("Executions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetExecutionsReplyValidationError{
						field:  fmt.Sprintf("Executions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetExecutionsReplyValidationError{
					field:  fmt.Sprintf("Executions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NextCursor

	if len(errors) > 0 {
		return GetExecutionsReplyMultiError(errors)
	}

	return nil
}

// GetExecutionsReplyMultiError is an error wrapping multiple validation errors
// returned by GetExecutionsReply.ValidateAll() if the designated constraints
// aren't met.
type GetExecutionsReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetExecutionsReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetExecutionsReplyMultiError) AllErrors() []error { return m }

// GetExecutionsReplyValidationError is the validation error returned by
// GetExecutionsReply.Validate if the designated constraints aren't met.
type GetExecutionsReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetExecutionsReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetExecutionsReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetExecutionsReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetExecutionsReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetExecutionsReplyValidationError) ErrorName() string {
	return "GetExecutionsReplyValidationError"
}

// Error satisfies the builtin error interface
func (e GetExecutionsReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetExecutionsReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetExecutionsReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetExecutionsReplyValidationError{}

// Validate checks the field values on GetExecutionReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetExecutionReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetExecutionReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetExecutionReqMultiError, or nil if none found.
func (m *GetExecutionReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetExecutionReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetWorkflowId()); l < 1 || l > 20 {
		err := GetExecutionReqValidationError{
			field:  "WorkflowId",
			reason: "value length must be between 1 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetId()); l < 1 || l > 20 {
		err := GetExecutionReqValidationError{
			field:  "Id",
			reason: "value length must be between 1 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetExecutionReqMultiError(errors)
	}

	return nil
}

// GetExecutionReqMultiError is an error wrapping multiple validation errors
// returned by GetExecutionReq.ValidateAll() if the designated constraints
// aren't met.
type GetExecutionReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetExecutionReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetExecutionReqMultiError) AllErrors() []error { return m }

// GetExecutionReqValidationError is the validation error returned by
// GetExecutionReq.Validate if the designated constraints aren't met.
type GetExecutionReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetExecutionReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetExecutionReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetExecutionReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetExecutionReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetExecutionReqValidationError) ErrorName() string { return "GetExecutionReqValidationError" }

// Error satisfies the builtin error interface
func (e GetExecutionReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetExecutionReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetExecutionReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetExecutionReqValidationError{}

// Validate checks the field values on GetExecutionReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetExecutionReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetExecutionReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetExecutionReplyMultiError, or nil if none found.
func (m *GetExecutionReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetExecutionReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetExecution()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetExecutionReplyValidationError{
					field:  "Execution",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetExecutionReplyValidationError{
					field:  "Execution",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExecution()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetExecutionReplyValidationError{
				field:  "Execution",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetExecutionReplyMultiError(errors)
	}

	return nil
}

// GetExecutionReplyMultiError is an error wrapping multiple validation errors
// returned by GetExecutionReply.ValidateAll() if the designated constraints
// aren't met.
type GetExecutionReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetExecutionReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetExecutionReplyMultiError) AllErrors() []error { return m }

// GetExecutionReplyValidationError is the validation error returned by
// GetExecutionReply.Validate if the designated constraints aren't met.
type GetExecutionReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetExecutionReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetExecutionReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetExecutionReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetExecutionReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetExecutionReplyValidationError) ErrorName() string {
	return "GetExecutionReplyValidationError"
}

// Error satisfies the builtin error interface
func (e GetExecutionReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetExecutionReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetExecutionReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetExecutionReplyValidationError{}

// Validate checks the field values on CallWebhookReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CallWebhookReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CallWebhookReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CallWebhookReqMultiError,
// or nil if none found.
func (m *CallWebhookReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CallWebhookReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetWebhookId()); l < 1 || l > 40 {
		err := CallWebhookReqValidationError{
			field:  "WebhookId",
			reason: "value length must be between 1 and 40 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CallWebhookReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CallWebhookReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CallWebhookReqValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CallWebhookReqMultiError(errors)
	}

	return nil
}

// CallWebhookReqMultiError is an error wrapping multiple validation errors
// returned by CallWebhookReq.ValidateAll() if the designated constraints
// aren't met.
type CallWebhookReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CallWebhookReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CallWebhookReqMultiError) AllErrors() []error { return m }

// CallWebhookReqValidationError is the validation error returned by
// CallWebhookReq.Validate if the designated constraints aren't met.
type CallWebhookReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CallWebhookReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CallWebhookReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CallWebhookReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CallWebhookReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CallWebhookReqValidationError) ErrorName() string { return "CallWebhookReqValidationError" }

// Error satisfies the builtin error interface
func (e CallWebhookReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCallWebhookReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CallWebhookReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CallWebhookReqValidationError{}

// Validate checks the field values on CallWebhookReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CallWebhookReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CallWebhookReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CallWebhookReplyMultiError, or nil if none found.
func (m *CallWebhookReply) ValidateAll() error {
	return m.validate(true)
}

func (m *CallWebhookReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return CallWebhookReplyMultiError(errors)
	}

	return nil
}

// CallWebhookReplyMultiError is an error wrapping multiple validation errors
// returned by CallWebhookReply.ValidateAll() if the designated constraints
// aren't met.
type CallWebhookReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CallWebhookReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CallWebhookReplyMultiError) AllErrors() []error { return m }

// CallWebhookReplyValidationError is the validation error returned by
// CallWebhookReply.Validate if the designated constraints aren't met.
type CallWebhookReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CallWebhookReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CallWebhookReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CallWebhookReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CallWebhookReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CallWebhookReplyValidationError) ErrorName() string { return "CallWebhookReplyValidationError" }

// Error satisfies the builtin error interface
func (e CallWebhookReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCallWebhookReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CallWebhookReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CallWebhookReplyValidationError{}

// Validate checks the field values on SaveIntegrationReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SaveIntegrationReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SaveIntegrationReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SaveIntegrationReqMultiError, or nil if none found.
func (m *SaveIntegrationReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SaveIntegrationReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 0 || l > 20 {
		err := SaveIntegrationReqValidationError{
			field:  "Id",
			reason: "value length must be between 0 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetInput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SaveIntegrationReqValidationError{
					field:  "Input",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SaveIntegrationReqValidationError{
					field:  "Input",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SaveIntegrationReqValidationError{
				field:  "Input",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SaveIntegrationReqMultiError(errors)
	}

	return nil
}

// SaveIntegrationReqMultiError is an error wrapping multiple validation errors
// returned by SaveIntegrationReq.ValidateAll() if the designated constraints
// aren't met.
type SaveIntegrationReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SaveIntegrationReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SaveIntegrationReqMultiError) AllErrors() []error { return m }

// SaveIntegrationReqValidationError is the validation error returned by
// SaveIntegrationReq.Validate if the designated constraints aren't met.
type SaveIntegrationReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SaveIntegrationReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SaveIntegrationReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SaveIntegrationReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SaveIntegrationReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SaveIntegrationReqValidationError) ErrorName() string {
	return "SaveIntegrationReqValidationError"
}

// Error satisfies the builtin error interface
func (e SaveIntegrationReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSaveIntegrationReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SaveIntegrationReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SaveIntegrationReqValidationError{}

// Validate checks the field values on SaveIntegrationReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SaveIntegrationReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SaveIntegrationReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SaveIntegrationReplyMultiError, or nil if none found.
func (m *SaveIntegrationReply) ValidateAll() error {
	return m.validate(true)
}

func (m *SaveIntegrationReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetIntegration()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SaveIntegrationReplyValidationError{
					field:  "Integration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SaveIntegrationReplyValidationError{
					field:  "Integration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIntegration()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SaveIntegrationReplyValidationError{
				field:  "Integration",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SaveIntegrationReplyMultiError(errors)
	}

	return nil
}

// SaveIntegrationReplyMultiError is an error wrapping multiple validation
// errors returned by SaveIntegrationReply.ValidateAll() if the designated
// constraints aren't met.
type SaveIntegrationReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SaveIntegrationReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SaveIntegrationReplyMultiError) AllErrors() []error { return m }

// SaveIntegrationReplyValidationError is the validation error returned by
// SaveIntegrationReply.Validate if the designated constraints aren't met.
type SaveIntegrationReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SaveIntegrationReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SaveIntegrationReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SaveIntegrationReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SaveIntegrationReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SaveIntegrationReplyValidationError) ErrorName() string {
	return "SaveIntegrationReplyValidationError"
}

// Error satisfies the builtin error interface
func (e SaveIntegrationReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSaveIntegrationReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SaveIntegrationReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SaveIntegrationReplyValidationError{}

// Validate checks the field values on GetIntegrationsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetIntegrationsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetIntegrationsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetIntegrationsReqMultiError, or nil if none found.
func (m *GetIntegrationsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetIntegrationsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetIntegrationsReqMultiError(errors)
	}

	return nil
}

// GetIntegrationsReqMultiError is an error wrapping multiple validation errors
// returned by GetIntegrationsReq.ValidateAll() if the designated constraints
// aren't met.
type GetIntegrationsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetIntegrationsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetIntegrationsReqMultiError) AllErrors() []error { return m }

// GetIntegrationsReqValidationError is the validation error returned by
// GetIntegrationsReq.Validate if the designated constraints aren't met.
type GetIntegrationsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetIntegrationsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetIntegrationsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetIntegrationsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetIntegrationsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetIntegrationsReqValidationError) ErrorName() string {
	return "GetIntegrationsReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetIntegrationsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetIntegrationsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetIntegrationsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetIntegrationsReqValidationError{}

// Validate checks the field values on GetIntegrationsReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetIntegrationsReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetIntegrationsReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetIntegrationsReplyMultiError, or nil if none found.
func (m *GetIntegrationsReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetIntegrationsReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetIntegrations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetIntegrationsReplyValidationError{
						field:  fmt.Sprintf("Integrations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetIntegrationsReplyValidationError{
						field:  fmt.Sprintf("Integrations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetIntegrationsReplyValidationError{
					field:  fmt.Sprintf("Integrations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetIntegrationsReplyMultiError(errors)
	}

	return nil
}

// GetIntegrationsReplyMultiError is an error wrapping multiple validation
// errors returned by GetIntegrationsReply.ValidateAll() if the designated
// constraints aren't met.
type GetIntegrationsReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetIntegrationsReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetIntegrationsReplyMultiError) AllErrors() []error { return m }

// GetIntegrationsReplyValidationError is the validation error returned by
// GetIntegrationsReply.Validate if the designated constraints aren't met.
type GetIntegrationsReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetIntegrationsReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetIntegrationsReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetIntegrationsReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetIntegrationsReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetIntegrationsReplyValidationError) ErrorName() string {
	return "GetIntegrationsReplyValidationError"
}

// Error satisfies the builtin error interface
func (e GetIntegrationsReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetIntegrationsReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetIntegrationsReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetIntegrationsReplyValidationError{}

// Validate checks the field values on GetIntegrationsByTypeReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetIntegrationsByTypeReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetIntegrationsByTypeReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetIntegrationsByTypeReqMultiError, or nil if none found.
func (m *GetIntegrationsByTypeReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetIntegrationsByTypeReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	if len(errors) > 0 {
		return GetIntegrationsByTypeReqMultiError(errors)
	}

	return nil
}

// GetIntegrationsByTypeReqMultiError is an error wrapping multiple validation
// errors returned by GetIntegrationsByTypeReq.ValidateAll() if the designated
// constraints aren't met.
type GetIntegrationsByTypeReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetIntegrationsByTypeReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetIntegrationsByTypeReqMultiError) AllErrors() []error { return m }

// GetIntegrationsByTypeReqValidationError is the validation error returned by
// GetIntegrationsByTypeReq.Validate if the designated constraints aren't met.
type GetIntegrationsByTypeReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetIntegrationsByTypeReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetIntegrationsByTypeReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetIntegrationsByTypeReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetIntegrationsByTypeReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetIntegrationsByTypeReqValidationError) ErrorName() string {
	return "GetIntegrationsByTypeReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetIntegrationsByTypeReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetIntegrationsByTypeReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetIntegrationsByTypeReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetIntegrationsByTypeReqValidationError{}

// Validate checks the field values on GetIntegrationsByTypeReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetIntegrationsByTypeReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetIntegrationsByTypeReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetIntegrationsByTypeReplyMultiError, or nil if none found.
func (m *GetIntegrationsByTypeReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetIntegrationsByTypeReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetIntegrations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetIntegrationsByTypeReplyValidationError{
						field:  fmt.Sprintf("Integrations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetIntegrationsByTypeReplyValidationError{
						field:  fmt.Sprintf("Integrations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetIntegrationsByTypeReplyValidationError{
					field:  fmt.Sprintf("Integrations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetIntegrationsByTypeReplyMultiError(errors)
	}

	return nil
}

// GetIntegrationsByTypeReplyMultiError is an error wrapping multiple
// validation errors returned by GetIntegrationsByTypeReply.ValidateAll() if
// the designated constraints aren't met.
type GetIntegrationsByTypeReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetIntegrationsByTypeReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetIntegrationsByTypeReplyMultiError) AllErrors() []error { return m }

// GetIntegrationsByTypeReplyValidationError is the validation error returned
// by GetIntegrationsByTypeReply.Validate if the designated constraints aren't met.
type GetIntegrationsByTypeReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetIntegrationsByTypeReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetIntegrationsByTypeReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetIntegrationsByTypeReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetIntegrationsByTypeReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetIntegrationsByTypeReplyValidationError) ErrorName() string {
	return "GetIntegrationsByTypeReplyValidationError"
}

// Error satisfies the builtin error interface
func (e GetIntegrationsByTypeReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetIntegrationsByTypeReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetIntegrationsByTypeReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetIntegrationsByTypeReplyValidationError{}

// Validate checks the field values on GetIntegrationReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetIntegrationReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetIntegrationReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetIntegrationReqMultiError, or nil if none found.
func (m *GetIntegrationReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetIntegrationReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 1 || l > 20 {
		err := GetIntegrationReqValidationError{
			field:  "Id",
			reason: "value length must be between 1 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetIntegrationReqMultiError(errors)
	}

	return nil
}

// GetIntegrationReqMultiError is an error wrapping multiple validation errors
// returned by GetIntegrationReq.ValidateAll() if the designated constraints
// aren't met.
type GetIntegrationReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetIntegrationReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetIntegrationReqMultiError) AllErrors() []error { return m }

// GetIntegrationReqValidationError is the validation error returned by
// GetIntegrationReq.Validate if the designated constraints aren't met.
type GetIntegrationReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetIntegrationReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetIntegrationReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetIntegrationReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetIntegrationReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetIntegrationReqValidationError) ErrorName() string {
	return "GetIntegrationReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetIntegrationReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetIntegrationReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetIntegrationReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetIntegrationReqValidationError{}

// Validate checks the field values on GetIntegrationReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetIntegrationReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetIntegrationReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetIntegrationReplyMultiError, or nil if none found.
func (m *GetIntegrationReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetIntegrationReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetIntegration()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetIntegrationReplyValidationError{
					field:  "Integration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetIntegrationReplyValidationError{
					field:  "Integration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIntegration()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetIntegrationReplyValidationError{
				field:  "Integration",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetIntegrationReplyMultiError(errors)
	}

	return nil
}

// GetIntegrationReplyMultiError is an error wrapping multiple validation
// errors returned by GetIntegrationReply.ValidateAll() if the designated
// constraints aren't met.
type GetIntegrationReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetIntegrationReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetIntegrationReplyMultiError) AllErrors() []error { return m }

// GetIntegrationReplyValidationError is the validation error returned by
// GetIntegrationReply.Validate if the designated constraints aren't met.
type GetIntegrationReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetIntegrationReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetIntegrationReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetIntegrationReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetIntegrationReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetIntegrationReplyValidationError) ErrorName() string {
	return "GetIntegrationReplyValidationError"
}

// Error satisfies the builtin error interface
func (e GetIntegrationReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetIntegrationReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetIntegrationReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetIntegrationReplyValidationError{}

// Validate checks the field values on DeleteIntegrationReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteIntegrationReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteIntegrationReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteIntegrationReqMultiError, or nil if none found.
func (m *DeleteIntegrationReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteIntegrationReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 1 || l > 20 {
		err := DeleteIntegrationReqValidationError{
			field:  "Id",
			reason: "value length must be between 1 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteIntegrationReqMultiError(errors)
	}

	return nil
}

// DeleteIntegrationReqMultiError is an error wrapping multiple validation
// errors returned by DeleteIntegrationReq.ValidateAll() if the designated
// constraints aren't met.
type DeleteIntegrationReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteIntegrationReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteIntegrationReqMultiError) AllErrors() []error { return m }

// DeleteIntegrationReqValidationError is the validation error returned by
// DeleteIntegrationReq.Validate if the designated constraints aren't met.
type DeleteIntegrationReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteIntegrationReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteIntegrationReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteIntegrationReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteIntegrationReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteIntegrationReqValidationError) ErrorName() string {
	return "DeleteIntegrationReqValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteIntegrationReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteIntegrationReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteIntegrationReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteIntegrationReqValidationError{}

// Validate checks the field values on DeleteIntegrationReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteIntegrationReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteIntegrationReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteIntegrationReplyMultiError, or nil if none found.
func (m *DeleteIntegrationReply) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteIntegrationReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteIntegrationReplyMultiError(errors)
	}

	return nil
}

// DeleteIntegrationReplyMultiError is an error wrapping multiple validation
// errors returned by DeleteIntegrationReply.ValidateAll() if the designated
// constraints aren't met.
type DeleteIntegrationReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteIntegrationReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteIntegrationReplyMultiError) AllErrors() []error { return m }

// DeleteIntegrationReplyValidationError is the validation error returned by
// DeleteIntegrationReply.Validate if the designated constraints aren't met.
type DeleteIntegrationReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteIntegrationReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteIntegrationReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteIntegrationReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteIntegrationReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteIntegrationReplyValidationError) ErrorName() string {
	return "DeleteIntegrationReplyValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteIntegrationReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteIntegrationReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteIntegrationReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteIntegrationReplyValidationError{}

// Validate checks the field values on GetTodoReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetTodoReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTodoReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetTodoReqMultiError, or
// nil if none found.
func (m *GetTodoReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTodoReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 1 || l > 20 {
		err := GetTodoReqValidationError{
			field:  "Id",
			reason: "value length must be between 1 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetTodoReqMultiError(errors)
	}

	return nil
}

// GetTodoReqMultiError is an error wrapping multiple validation errors
// returned by GetTodoReq.ValidateAll() if the designated constraints aren't met.
type GetTodoReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTodoReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTodoReqMultiError) AllErrors() []error { return m }

// GetTodoReqValidationError is the validation error returned by
// GetTodoReq.Validate if the designated constraints aren't met.
type GetTodoReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTodoReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTodoReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTodoReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTodoReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTodoReqValidationError) ErrorName() string { return "GetTodoReqValidationError" }

// Error satisfies the builtin error interface
func (e GetTodoReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTodoReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTodoReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTodoReqValidationError{}

// Validate checks the field values on GetTodoReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetTodoReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTodoReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetTodoReplyMultiError, or
// nil if none found.
func (m *GetTodoReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTodoReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTodo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetTodoReplyValidationError{
					field:  "Todo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetTodoReplyValidationError{
					field:  "Todo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTodo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTodoReplyValidationError{
				field:  "Todo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetTodoReplyMultiError(errors)
	}

	return nil
}

// GetTodoReplyMultiError is an error wrapping multiple validation errors
// returned by GetTodoReply.ValidateAll() if the designated constraints aren't met.
type GetTodoReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTodoReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTodoReplyMultiError) AllErrors() []error { return m }

// GetTodoReplyValidationError is the validation error returned by
// GetTodoReply.Validate if the designated constraints aren't met.
type GetTodoReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTodoReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTodoReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTodoReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTodoReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTodoReplyValidationError) ErrorName() string { return "GetTodoReplyValidationError" }

// Error satisfies the builtin error interface
func (e GetTodoReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTodoReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTodoReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTodoReplyValidationError{}

// Validate checks the field values on GetTodosByExecutionReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTodosByExecutionReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTodosByExecutionReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTodosByExecutionReqMultiError, or nil if none found.
func (m *GetTodosByExecutionReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTodosByExecutionReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetIssueId() <= 0 {
		err := GetTodosByExecutionReqValidationError{
			field:  "IssueId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetExecutionId() <= 0 {
		err := GetTodosByExecutionReqValidationError{
			field:  "ExecutionId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetAuditFlowId()); l < 1 || l > 128 {
		err := GetTodosByExecutionReqValidationError{
			field:  "AuditFlowId",
			reason: "value length must be between 1 and 128 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetTodosByExecutionReqMultiError(errors)
	}

	return nil
}

// GetTodosByExecutionReqMultiError is an error wrapping multiple validation
// errors returned by GetTodosByExecutionReq.ValidateAll() if the designated
// constraints aren't met.
type GetTodosByExecutionReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTodosByExecutionReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTodosByExecutionReqMultiError) AllErrors() []error { return m }

// GetTodosByExecutionReqValidationError is the validation error returned by
// GetTodosByExecutionReq.Validate if the designated constraints aren't met.
type GetTodosByExecutionReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTodosByExecutionReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTodosByExecutionReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTodosByExecutionReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTodosByExecutionReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTodosByExecutionReqValidationError) ErrorName() string {
	return "GetTodosByExecutionReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetTodosByExecutionReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTodosByExecutionReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTodosByExecutionReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTodosByExecutionReqValidationError{}

// Validate checks the field values on GetTodosByExecutionReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTodosByExecutionReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTodosByExecutionReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTodosByExecutionReplyMultiError, or nil if none found.
func (m *GetTodosByExecutionReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTodosByExecutionReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTodos() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetTodosByExecutionReplyValidationError{
						field:  fmt.Sprintf("Todos[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetTodosByExecutionReplyValidationError{
						field:  fmt.Sprintf("Todos[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetTodosByExecutionReplyValidationError{
					field:  fmt.Sprintf("Todos[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetTodosByExecutionReplyMultiError(errors)
	}

	return nil
}

// GetTodosByExecutionReplyMultiError is an error wrapping multiple validation
// errors returned by GetTodosByExecutionReply.ValidateAll() if the designated
// constraints aren't met.
type GetTodosByExecutionReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTodosByExecutionReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTodosByExecutionReplyMultiError) AllErrors() []error { return m }

// GetTodosByExecutionReplyValidationError is the validation error returned by
// GetTodosByExecutionReply.Validate if the designated constraints aren't met.
type GetTodosByExecutionReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTodosByExecutionReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTodosByExecutionReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTodosByExecutionReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTodosByExecutionReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTodosByExecutionReplyValidationError) ErrorName() string {
	return "GetTodosByExecutionReplyValidationError"
}

// Error satisfies the builtin error interface
func (e GetTodosByExecutionReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTodosByExecutionReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTodosByExecutionReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTodosByExecutionReplyValidationError{}

// Validate checks the field values on TodoStatReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TodoStatReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TodoStatReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TodoStatReqMultiError, or
// nil if none found.
func (m *TodoStatReq) ValidateAll() error {
	return m.validate(true)
}

func (m *TodoStatReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return TodoStatReqMultiError(errors)
	}

	return nil
}

// TodoStatReqMultiError is an error wrapping multiple validation errors
// returned by TodoStatReq.ValidateAll() if the designated constraints aren't met.
type TodoStatReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TodoStatReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TodoStatReqMultiError) AllErrors() []error { return m }

// TodoStatReqValidationError is the validation error returned by
// TodoStatReq.Validate if the designated constraints aren't met.
type TodoStatReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TodoStatReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TodoStatReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TodoStatReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TodoStatReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TodoStatReqValidationError) ErrorName() string { return "TodoStatReqValidationError" }

// Error satisfies the builtin error interface
func (e TodoStatReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTodoStatReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TodoStatReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TodoStatReqValidationError{}

// Validate checks the field values on TodoStatReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TodoStatReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TodoStatReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TodoStatReplyMultiError, or
// nil if none found.
func (m *TodoStatReply) ValidateAll() error {
	return m.validate(true)
}

func (m *TodoStatReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetStats() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TodoStatReplyValidationError{
						field:  fmt.Sprintf("Stats[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TodoStatReplyValidationError{
						field:  fmt.Sprintf("Stats[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TodoStatReplyValidationError{
					field:  fmt.Sprintf("Stats[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TodoStatReplyMultiError(errors)
	}

	return nil
}

// TodoStatReplyMultiError is an error wrapping multiple validation errors
// returned by TodoStatReply.ValidateAll() if the designated constraints
// aren't met.
type TodoStatReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TodoStatReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TodoStatReplyMultiError) AllErrors() []error { return m }

// TodoStatReplyValidationError is the validation error returned by
// TodoStatReply.Validate if the designated constraints aren't met.
type TodoStatReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TodoStatReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TodoStatReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TodoStatReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TodoStatReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TodoStatReplyValidationError) ErrorName() string { return "TodoStatReplyValidationError" }

// Error satisfies the builtin error interface
func (e TodoStatReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTodoStatReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TodoStatReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TodoStatReplyValidationError{}

// Validate checks the field values on TodoFilterReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TodoFilterReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TodoFilterReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TodoFilterReqMultiError, or
// nil if none found.
func (m *TodoFilterReq) ValidateAll() error {
	return m.validate(true)
}

func (m *TodoFilterReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	// no validation rules for Page

	// no validation rules for Size

	// no validation rules for WorkflowName

	if len(errors) > 0 {
		return TodoFilterReqMultiError(errors)
	}

	return nil
}

// TodoFilterReqMultiError is an error wrapping multiple validation errors
// returned by TodoFilterReq.ValidateAll() if the designated constraints
// aren't met.
type TodoFilterReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TodoFilterReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TodoFilterReqMultiError) AllErrors() []error { return m }

// TodoFilterReqValidationError is the validation error returned by
// TodoFilterReq.Validate if the designated constraints aren't met.
type TodoFilterReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TodoFilterReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TodoFilterReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TodoFilterReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TodoFilterReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TodoFilterReqValidationError) ErrorName() string { return "TodoFilterReqValidationError" }

// Error satisfies the builtin error interface
func (e TodoFilterReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTodoFilterReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TodoFilterReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TodoFilterReqValidationError{}

// Validate checks the field values on TodoFilterReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TodoFilterReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TodoFilterReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TodoFilterReplyMultiError, or nil if none found.
func (m *TodoFilterReply) ValidateAll() error {
	return m.validate(true)
}

func (m *TodoFilterReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTodos() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TodoFilterReplyValidationError{
						field:  fmt.Sprintf("Todos[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TodoFilterReplyValidationError{
						field:  fmt.Sprintf("Todos[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TodoFilterReplyValidationError{
					field:  fmt.Sprintf("Todos[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	if len(errors) > 0 {
		return TodoFilterReplyMultiError(errors)
	}

	return nil
}

// TodoFilterReplyMultiError is an error wrapping multiple validation errors
// returned by TodoFilterReply.ValidateAll() if the designated constraints
// aren't met.
type TodoFilterReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TodoFilterReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TodoFilterReplyMultiError) AllErrors() []error { return m }

// TodoFilterReplyValidationError is the validation error returned by
// TodoFilterReply.Validate if the designated constraints aren't met.
type TodoFilterReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TodoFilterReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TodoFilterReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TodoFilterReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TodoFilterReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TodoFilterReplyValidationError) ErrorName() string { return "TodoFilterReplyValidationError" }

// Error satisfies the builtin error interface
func (e TodoFilterReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTodoFilterReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TodoFilterReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TodoFilterReplyValidationError{}
