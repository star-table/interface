// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: automation_model.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on ActivateErrors with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ActivateErrors) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ActivateErrors with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ActivateErrorsMultiError,
// or nil if none found.
func (m *ActivateErrors) ValidateAll() error {
	return m.validate(true)
}

func (m *ActivateErrors) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetErrors() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActivateErrorsValidationError{
						field:  fmt.Sprintf("Errors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActivateErrorsValidationError{
						field:  fmt.Sprintf("Errors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActivateErrorsValidationError{
					field:  fmt.Sprintf("Errors[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ActivateErrorsMultiError(errors)
	}

	return nil
}

// ActivateErrorsMultiError is an error wrapping multiple validation errors
// returned by ActivateErrors.ValidateAll() if the designated constraints
// aren't met.
type ActivateErrorsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ActivateErrorsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ActivateErrorsMultiError) AllErrors() []error { return m }

// ActivateErrorsValidationError is the validation error returned by
// ActivateErrors.Validate if the designated constraints aren't met.
type ActivateErrorsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ActivateErrorsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ActivateErrorsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ActivateErrorsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ActivateErrorsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ActivateErrorsValidationError) ErrorName() string { return "ActivateErrorsValidationError" }

// Error satisfies the builtin error interface
func (e ActivateErrorsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sActivateErrors.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ActivateErrorsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ActivateErrorsValidationError{}

// Validate checks the field values on ActivateError with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ActivateError) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ActivateError with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ActivateErrorMultiError, or
// nil if none found.
func (m *ActivateError) ValidateAll() error {
	return m.validate(true)
}

func (m *ActivateError) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	if l := utf8.RuneCountInString(m.GetNode()); l < 1 || l > 128 {
		err := ActivateErrorValidationError{
			field:  "Node",
			reason: "value length must be between 1 and 128 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDesc()); l < 1 || l > 1024 {
		err := ActivateErrorValidationError{
			field:  "Desc",
			reason: "value length must be between 1 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ActivateErrorMultiError(errors)
	}

	return nil
}

// ActivateErrorMultiError is an error wrapping multiple validation errors
// returned by ActivateError.ValidateAll() if the designated constraints
// aren't met.
type ActivateErrorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ActivateErrorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ActivateErrorMultiError) AllErrors() []error { return m }

// ActivateErrorValidationError is the validation error returned by
// ActivateError.Validate if the designated constraints aren't met.
type ActivateErrorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ActivateErrorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ActivateErrorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ActivateErrorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ActivateErrorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ActivateErrorValidationError) ErrorName() string { return "ActivateErrorValidationError" }

// Error satisfies the builtin error interface
func (e ActivateErrorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sActivateError.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ActivateErrorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ActivateErrorValidationError{}

// Validate checks the field values on DataFromNode with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DataFromNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DataFromNode with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DataFromNodeMultiError, or
// nil if none found.
func (m *DataFromNode) ValidateAll() error {
	return m.validate(true)
}

func (m *DataFromNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetNode()); l < 1 || l > 128 {
		err := DataFromNodeValidationError{
			field:  "Node",
			reason: "value length must be between 1 and 128 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetIndex() < 0 {
		err := DataFromNodeValidationError{
			field:  "Index",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DataFromNodeMultiError(errors)
	}

	return nil
}

// DataFromNodeMultiError is an error wrapping multiple validation errors
// returned by DataFromNode.ValidateAll() if the designated constraints aren't met.
type DataFromNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DataFromNodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DataFromNodeMultiError) AllErrors() []error { return m }

// DataFromNodeValidationError is the validation error returned by
// DataFromNode.Validate if the designated constraints aren't met.
type DataFromNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DataFromNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DataFromNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DataFromNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DataFromNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DataFromNodeValidationError) ErrorName() string { return "DataFromNodeValidationError" }

// Error satisfies the builtin error interface
func (e DataFromNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDataFromNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DataFromNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DataFromNodeValidationError{}

// Validate checks the field values on DynamicValueFromNode with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DynamicValueFromNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DynamicValueFromNode with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DynamicValueFromNodeMultiError, or nil if none found.
func (m *DynamicValueFromNode) ValidateAll() error {
	return m.validate(true)
}

func (m *DynamicValueFromNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetNode()); l < 1 || l > 128 {
		err := DynamicValueFromNodeValidationError{
			field:  "Node",
			reason: "value length must be between 1 and 128 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetIndex() < 0 {
		err := DynamicValueFromNodeValidationError{
			field:  "Index",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetKeyPath()); l < 0 || l > 128 {
		err := DynamicValueFromNodeValidationError{
			field:  "KeyPath",
			reason: "value length must be between 0 and 128 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DynamicValueFromNodeMultiError(errors)
	}

	return nil
}

// DynamicValueFromNodeMultiError is an error wrapping multiple validation
// errors returned by DynamicValueFromNode.ValidateAll() if the designated
// constraints aren't met.
type DynamicValueFromNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DynamicValueFromNodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DynamicValueFromNodeMultiError) AllErrors() []error { return m }

// DynamicValueFromNodeValidationError is the validation error returned by
// DynamicValueFromNode.Validate if the designated constraints aren't met.
type DynamicValueFromNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DynamicValueFromNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DynamicValueFromNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DynamicValueFromNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DynamicValueFromNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DynamicValueFromNodeValidationError) ErrorName() string {
	return "DynamicValueFromNodeValidationError"
}

// Error satisfies the builtin error interface
func (e DynamicValueFromNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDynamicValueFromNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DynamicValueFromNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DynamicValueFromNodeValidationError{}

// Validate checks the field values on DynamicValueElement with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DynamicValueElement) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DynamicValueElement with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DynamicValueElementMultiError, or nil if none found.
func (m *DynamicValueElement) ValidateAll() error {
	return m.validate(true)
}

func (m *DynamicValueElement) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.Data.(type) {

	case *DynamicValueElement_Text:

		if l := utf8.RuneCountInString(m.GetText()); l < 1 || l > 10240 {
			err := DynamicValueElementValidationError{
				field:  "Text",
				reason: "value length must be between 1 and 10240 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	case *DynamicValueElement_Value:

		if all {
			switch v := interface{}(m.GetValue()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DynamicValueElementValidationError{
						field:  "Value",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DynamicValueElementValidationError{
						field:  "Value",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetValue()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DynamicValueElementValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DynamicValueElementMultiError(errors)
	}

	return nil
}

// DynamicValueElementMultiError is an error wrapping multiple validation
// errors returned by DynamicValueElement.ValidateAll() if the designated
// constraints aren't met.
type DynamicValueElementMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DynamicValueElementMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DynamicValueElementMultiError) AllErrors() []error { return m }

// DynamicValueElementValidationError is the validation error returned by
// DynamicValueElement.Validate if the designated constraints aren't met.
type DynamicValueElementValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DynamicValueElementValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DynamicValueElementValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DynamicValueElementValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DynamicValueElementValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DynamicValueElementValidationError) ErrorName() string {
	return "DynamicValueElementValidationError"
}

// Error satisfies the builtin error interface
func (e DynamicValueElementValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDynamicValueElement.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DynamicValueElementValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DynamicValueElementValidationError{}

// Validate checks the field values on DynamicValue with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DynamicValue) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DynamicValue with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DynamicValueMultiError, or
// nil if none found.
func (m *DynamicValue) ValidateAll() error {
	return m.validate(true)
}

func (m *DynamicValue) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetElement()) < 1 {
		err := DynamicValueValidationError{
			field:  "Element",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetElement() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DynamicValueValidationError{
						field:  fmt.Sprintf("Element[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DynamicValueValidationError{
						field:  fmt.Sprintf("Element[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DynamicValueValidationError{
					field:  fmt.Sprintf("Element[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DynamicValueMultiError(errors)
	}

	return nil
}

// DynamicValueMultiError is an error wrapping multiple validation errors
// returned by DynamicValue.ValidateAll() if the designated constraints aren't met.
type DynamicValueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DynamicValueMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DynamicValueMultiError) AllErrors() []error { return m }

// DynamicValueValidationError is the validation error returned by
// DynamicValue.Validate if the designated constraints aren't met.
type DynamicValueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DynamicValueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DynamicValueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DynamicValueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DynamicValueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DynamicValueValidationError) ErrorName() string { return "DynamicValueValidationError" }

// Error satisfies the builtin error interface
func (e DynamicValueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDynamicValue.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DynamicValueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DynamicValueValidationError{}

// Validate checks the field values on Value with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Value) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Value with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ValueMultiError, or nil if none found.
func (m *Value) ValidateAll() error {
	return m.validate(true)
}

func (m *Value) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetDisplayJson()); l < 0 || l > 1024 {
		err := ValueValidationError{
			field:  "DisplayJson",
			reason: "value length must be between 0 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	switch m.Value.(type) {

	case *Value_Json:

		if l := utf8.RuneCountInString(m.GetJson()); l < 1 || l > 10240 {
			err := ValueValidationError{
				field:  "Json",
				reason: "value length must be between 1 and 10240 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	case *Value_Dynamic:

		if all {
			switch v := interface{}(m.GetDynamic()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ValueValidationError{
						field:  "Dynamic",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ValueValidationError{
						field:  "Dynamic",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDynamic()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ValueValidationError{
					field:  "Dynamic",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Value_Expression:

		if l := utf8.RuneCountInString(m.GetExpression()); l < 1 || l > 10240 {
			err := ValueValidationError{
				field:  "Expression",
				reason: "value length must be between 1 and 10240 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	case *Value_System:
		// no validation rules for System

	}

	if len(errors) > 0 {
		return ValueMultiError(errors)
	}

	return nil
}

// ValueMultiError is an error wrapping multiple validation errors returned by
// Value.ValidateAll() if the designated constraints aren't met.
type ValueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ValueMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ValueMultiError) AllErrors() []error { return m }

// ValueValidationError is the validation error returned by Value.Validate if
// the designated constraints aren't met.
type ValueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ValueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ValueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ValueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ValueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ValueValidationError) ErrorName() string { return "ValueValidationError" }

// Error satisfies the builtin error interface
func (e ValueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sValue.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ValueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ValueValidationError{}

// Validate checks the field values on StringValue with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StringValue) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StringValue with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StringValueMultiError, or
// nil if none found.
func (m *StringValue) ValidateAll() error {
	return m.validate(true)
}

func (m *StringValue) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.Value.(type) {

	case *StringValue_Dynamic:

		if all {
			switch v := interface{}(m.GetDynamic()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StringValueValidationError{
						field:  "Dynamic",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StringValueValidationError{
						field:  "Dynamic",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDynamic()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StringValueValidationError{
					field:  "Dynamic",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *StringValue_Expression:

		if l := utf8.RuneCountInString(m.GetExpression()); l < 1 || l > 10240 {
			err := StringValueValidationError{
				field:  "Expression",
				reason: "value length must be between 1 and 10240 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	case *StringValue_Text:

		if l := utf8.RuneCountInString(m.GetText()); l < 1 || l > 10240 {
			err := StringValueValidationError{
				field:  "Text",
				reason: "value length must be between 1 and 10240 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	case *StringValue_Json:

		if l := utf8.RuneCountInString(m.GetJson()); l < 1 || l > 10240 {
			err := StringValueValidationError{
				field:  "Json",
				reason: "value length must be between 1 and 10240 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return StringValueMultiError(errors)
	}

	return nil
}

// StringValueMultiError is an error wrapping multiple validation errors
// returned by StringValue.ValidateAll() if the designated constraints aren't met.
type StringValueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StringValueMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StringValueMultiError) AllErrors() []error { return m }

// StringValueValidationError is the validation error returned by
// StringValue.Validate if the designated constraints aren't met.
type StringValueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StringValueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StringValueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StringValueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StringValueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StringValueValidationError) ErrorName() string { return "StringValueValidationError" }

// Error satisfies the builtin error interface
func (e StringValueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStringValue.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StringValueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StringValueValidationError{}

// Validate checks the field values on KeyValue with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *KeyValue) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on KeyValue with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in KeyValueMultiError, or nil
// if none found.
func (m *KeyValue) ValidateAll() error {
	return m.validate(true)
}

func (m *KeyValue) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetKey()); l < 1 || l > 128 {
		err := KeyValueValidationError{
			field:  "Key",
			reason: "value length must be between 1 and 128 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, KeyValueValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, KeyValueValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return KeyValueValidationError{
				field:  "Value",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return KeyValueMultiError(errors)
	}

	return nil
}

// KeyValueMultiError is an error wrapping multiple validation errors returned
// by KeyValue.ValidateAll() if the designated constraints aren't met.
type KeyValueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KeyValueMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KeyValueMultiError) AllErrors() []error { return m }

// KeyValueValidationError is the validation error returned by
// KeyValue.Validate if the designated constraints aren't met.
type KeyValueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KeyValueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KeyValueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KeyValueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KeyValueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KeyValueValidationError) ErrorName() string { return "KeyValueValidationError" }

// Error satisfies the builtin error interface
func (e KeyValueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKeyValue.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KeyValueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KeyValueValidationError{}

// Validate checks the field values on People with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *People) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on People with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PeopleMultiError, or nil if none found.
func (m *People) ValidateAll() error {
	return m.validate(true)
}

func (m *People) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	if all {
		switch v := interface{}(m.GetValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PeopleValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PeopleValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PeopleValidationError{
				field:  "Value",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PeopleMultiError(errors)
	}

	return nil
}

// PeopleMultiError is an error wrapping multiple validation errors returned by
// People.ValidateAll() if the designated constraints aren't met.
type PeopleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PeopleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PeopleMultiError) AllErrors() []error { return m }

// PeopleValidationError is the validation error returned by People.Validate if
// the designated constraints aren't met.
type PeopleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PeopleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PeopleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PeopleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PeopleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PeopleValidationError) ErrorName() string { return "PeopleValidationError" }

// Error satisfies the builtin error interface
func (e PeopleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPeople.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PeopleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PeopleValidationError{}

// Validate checks the field values on PeopleByIds with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PeopleByIds) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PeopleByIds with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PeopleByIdsMultiError, or
// nil if none found.
func (m *PeopleByIds) ValidateAll() error {
	return m.validate(true)
}

func (m *PeopleByIds) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	// no validation rules for IdsJson

	if len(errors) > 0 {
		return PeopleByIdsMultiError(errors)
	}

	return nil
}

// PeopleByIdsMultiError is an error wrapping multiple validation errors
// returned by PeopleByIds.ValidateAll() if the designated constraints aren't met.
type PeopleByIdsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PeopleByIdsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PeopleByIdsMultiError) AllErrors() []error { return m }

// PeopleByIdsValidationError is the validation error returned by
// PeopleByIds.Validate if the designated constraints aren't met.
type PeopleByIdsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PeopleByIdsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PeopleByIdsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PeopleByIdsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PeopleByIdsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PeopleByIdsValidationError) ErrorName() string { return "PeopleByIdsValidationError" }

// Error satisfies the builtin error interface
func (e PeopleByIdsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPeopleByIds.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PeopleByIdsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PeopleByIdsValidationError{}

// Validate checks the field values on TodoOperatorResultsById with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TodoOperatorResultsById) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TodoOperatorResultsById with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TodoOperatorResultsByIdMultiError, or nil if none found.
func (m *TodoOperatorResultsById) ValidateAll() error {
	return m.validate(true)
}

func (m *TodoOperatorResultsById) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]int64, len(m.GetResults()))
		i := 0
		for key := range m.GetResults() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetResults()[key]
			_ = val

			// no validation rules for Results[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, TodoOperatorResultsByIdValidationError{
							field:  fmt.Sprintf("Results[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, TodoOperatorResultsByIdValidationError{
							field:  fmt.Sprintf("Results[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return TodoOperatorResultsByIdValidationError{
						field:  fmt.Sprintf("Results[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return TodoOperatorResultsByIdMultiError(errors)
	}

	return nil
}

// TodoOperatorResultsByIdMultiError is an error wrapping multiple validation
// errors returned by TodoOperatorResultsById.ValidateAll() if the designated
// constraints aren't met.
type TodoOperatorResultsByIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TodoOperatorResultsByIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TodoOperatorResultsByIdMultiError) AllErrors() []error { return m }

// TodoOperatorResultsByIdValidationError is the validation error returned by
// TodoOperatorResultsById.Validate if the designated constraints aren't met.
type TodoOperatorResultsByIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TodoOperatorResultsByIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TodoOperatorResultsByIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TodoOperatorResultsByIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TodoOperatorResultsByIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TodoOperatorResultsByIdValidationError) ErrorName() string {
	return "TodoOperatorResultsByIdValidationError"
}

// Error satisfies the builtin error interface
func (e TodoOperatorResultsByIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTodoOperatorResultsById.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TodoOperatorResultsByIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TodoOperatorResultsByIdValidationError{}

// Validate checks the field values on FormSetting with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FormSetting) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FormSetting with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FormSettingMultiError, or
// nil if none found.
func (m *FormSetting) ValidateAll() error {
	return m.validate(true)
}

func (m *FormSetting) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetColumnId()); l < 1 || l > 128 {
		err := FormSettingValidationError{
			field:  "ColumnId",
			reason: "value length must be between 1 and 128 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for CanRead

	// no validation rules for CanWrite

	// no validation rules for Required

	if len(errors) > 0 {
		return FormSettingMultiError(errors)
	}

	return nil
}

// FormSettingMultiError is an error wrapping multiple validation errors
// returned by FormSetting.ValidateAll() if the designated constraints aren't met.
type FormSettingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FormSettingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FormSettingMultiError) AllErrors() []error { return m }

// FormSettingValidationError is the validation error returned by
// FormSetting.Validate if the designated constraints aren't met.
type FormSettingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FormSettingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FormSettingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FormSettingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FormSettingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FormSettingValidationError) ErrorName() string { return "FormSettingValidationError" }

// Error satisfies the builtin error interface
func (e FormSettingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFormSetting.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FormSettingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FormSettingValidationError{}

// Validate checks the field values on FilterCondition with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *FilterCondition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FilterCondition with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FilterConditionMultiError, or nil if none found.
func (m *FilterCondition) ValidateAll() error {
	return m.validate(true)
}

func (m *FilterCondition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSource()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FilterConditionValidationError{
					field:  "Source",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FilterConditionValidationError{
					field:  "Source",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSource()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FilterConditionValidationError{
				field:  "Source",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if l := utf8.RuneCountInString(m.GetColumnId()); l < 0 || l > 128 {
		err := FilterConditionValidationError{
			field:  "ColumnId",
			reason: "value length must be between 0 and 128 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetFieldType()); l < 0 || l > 32 {
		err := FilterConditionValidationError{
			field:  "FieldType",
			reason: "value length must be between 0 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetType()); l < 1 || l > 32 {
		err := FilterConditionValidationError{
			field:  "Type",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetProps()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FilterConditionValidationError{
					field:  "Props",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FilterConditionValidationError{
					field:  "Props",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProps()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FilterConditionValidationError{
				field:  "Props",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FilterConditionValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FilterConditionValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FilterConditionValidationError{
				field:  "Value",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetConds() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FilterConditionValidationError{
						field:  fmt.Sprintf("Conds[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FilterConditionValidationError{
						field:  fmt.Sprintf("Conds[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FilterConditionValidationError{
					field:  fmt.Sprintf("Conds[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return FilterConditionMultiError(errors)
	}

	return nil
}

// FilterConditionMultiError is an error wrapping multiple validation errors
// returned by FilterCondition.ValidateAll() if the designated constraints
// aren't met.
type FilterConditionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FilterConditionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FilterConditionMultiError) AllErrors() []error { return m }

// FilterConditionValidationError is the validation error returned by
// FilterCondition.Validate if the designated constraints aren't met.
type FilterConditionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FilterConditionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FilterConditionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FilterConditionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FilterConditionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FilterConditionValidationError) ErrorName() string { return "FilterConditionValidationError" }

// Error satisfies the builtin error interface
func (e FilterConditionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFilterCondition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FilterConditionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FilterConditionValidationError{}

// Validate checks the field values on Filter with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Filter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Filter with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in FilterMultiError, or nil if none found.
func (m *Filter) ValidateAll() error {
	return m.validate(true)
}

func (m *Filter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 0 || l > 128 {
		err := FilterValidationError{
			field:  "Name",
			reason: "value length must be between 0 and 128 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetCondition()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FilterValidationError{
					field:  "Condition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FilterValidationError{
					field:  "Condition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCondition()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FilterValidationError{
				field:  "Condition",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return FilterMultiError(errors)
	}

	return nil
}

// FilterMultiError is an error wrapping multiple validation errors returned by
// Filter.ValidateAll() if the designated constraints aren't met.
type FilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FilterMultiError) AllErrors() []error { return m }

// FilterValidationError is the validation error returned by Filter.Validate if
// the designated constraints aren't met.
type FilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FilterValidationError) ErrorName() string { return "FilterValidationError" }

// Error satisfies the builtin error interface
func (e FilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FilterValidationError{}

// Validate checks the field values on Order with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Order) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Order with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in OrderMultiError, or nil if none found.
func (m *Order) ValidateAll() error {
	return m.validate(true)
}

func (m *Order) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetColumnId()); l < 1 || l > 128 {
		err := OrderValidationError{
			field:  "ColumnId",
			reason: "value length must be between 1 and 128 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Asc

	if len(errors) > 0 {
		return OrderMultiError(errors)
	}

	return nil
}

// OrderMultiError is an error wrapping multiple validation errors returned by
// Order.ValidateAll() if the designated constraints aren't met.
type OrderMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OrderMultiError) AllErrors() []error { return m }

// OrderValidationError is the validation error returned by Order.Validate if
// the designated constraints aren't met.
type OrderValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OrderValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OrderValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OrderValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OrderValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OrderValidationError) ErrorName() string { return "OrderValidationError" }

// Error satisfies the builtin error interface
func (e OrderValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOrder.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OrderValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OrderValidationError{}

// Validate checks the field values on StringMapping with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StringMapping) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StringMapping with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StringMappingMultiError, or
// nil if none found.
func (m *StringMapping) ValidateAll() error {
	return m.validate(true)
}

func (m *StringMapping) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Old

	// no validation rules for New

	if len(errors) > 0 {
		return StringMappingMultiError(errors)
	}

	return nil
}

// StringMappingMultiError is an error wrapping multiple validation errors
// returned by StringMapping.ValidateAll() if the designated constraints
// aren't met.
type StringMappingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StringMappingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StringMappingMultiError) AllErrors() []error { return m }

// StringMappingValidationError is the validation error returned by
// StringMapping.Validate if the designated constraints aren't met.
type StringMappingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StringMappingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StringMappingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StringMappingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StringMappingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StringMappingValidationError) ErrorName() string { return "StringMappingValidationError" }

// Error satisfies the builtin error interface
func (e StringMappingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStringMapping.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StringMappingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StringMappingValidationError{}

// Validate checks the field values on NumberMapping with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NumberMapping) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NumberMapping with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NumberMappingMultiError, or
// nil if none found.
func (m *NumberMapping) ValidateAll() error {
	return m.validate(true)
}

func (m *NumberMapping) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Old

	// no validation rules for New

	if len(errors) > 0 {
		return NumberMappingMultiError(errors)
	}

	return nil
}

// NumberMappingMultiError is an error wrapping multiple validation errors
// returned by NumberMapping.ValidateAll() if the designated constraints
// aren't met.
type NumberMappingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NumberMappingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NumberMappingMultiError) AllErrors() []error { return m }

// NumberMappingValidationError is the validation error returned by
// NumberMapping.Validate if the designated constraints aren't met.
type NumberMappingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NumberMappingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NumberMappingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NumberMappingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NumberMappingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NumberMappingValidationError) ErrorName() string { return "NumberMappingValidationError" }

// Error satisfies the builtin error interface
func (e NumberMappingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNumberMapping.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NumberMappingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NumberMappingValidationError{}

// Validate checks the field values on TriggerBy with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TriggerBy) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TriggerBy with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TriggerByMultiError, or nil
// if none found.
func (m *TriggerBy) ValidateAll() error {
	return m.validate(true)
}

func (m *TriggerBy) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetTriggerBy()) < 1 {
		err := TriggerByValidationError{
			field:  "TriggerBy",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetWorkflowId()); l < 1 || l > 20 {
		err := TriggerByValidationError{
			field:  "WorkflowId",
			reason: "value length must be between 1 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetWorkflowName()); l < 0 || l > 128 {
		err := TriggerByValidationError{
			field:  "WorkflowName",
			reason: "value length must be between 0 and 128 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetExecutionId() <= 0 {
		err := TriggerByValidationError{
			field:  "ExecutionId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return TriggerByMultiError(errors)
	}

	return nil
}

// TriggerByMultiError is an error wrapping multiple validation errors returned
// by TriggerBy.ValidateAll() if the designated constraints aren't met.
type TriggerByMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TriggerByMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TriggerByMultiError) AllErrors() []error { return m }

// TriggerByValidationError is the validation error returned by
// TriggerBy.Validate if the designated constraints aren't met.
type TriggerByValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TriggerByValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TriggerByValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TriggerByValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TriggerByValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TriggerByValidationError) ErrorName() string { return "TriggerByValidationError" }

// Error satisfies the builtin error interface
func (e TriggerByValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTriggerBy.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TriggerByValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TriggerByValidationError{}

// Validate checks the field values on Node with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Node) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Node with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in NodeMultiError, or nil if none found.
func (m *Node) ValidateAll() error {
	return m.validate(true)
}

func (m *Node) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 1 || l > 128 {
		err := NodeValidationError{
			field:  "Id",
			reason: "value length must be between 1 and 128 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 0 || l > 128 {
		err := NodeValidationError{
			field:  "Name",
			reason: "value length must be between 0 and 128 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Type

	switch m.Parameters.(type) {

	case *Node_ActionAudit:

		if all {
			switch v := interface{}(m.GetActionAudit()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "ActionAudit",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "ActionAudit",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetActionAudit()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "ActionAudit",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_ActionCreateData:

		if all {
			switch v := interface{}(m.GetActionCreateData()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "ActionCreateData",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "ActionCreateData",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetActionCreateData()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "ActionCreateData",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_ActionFillIn:

		if all {
			switch v := interface{}(m.GetActionFillIn()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "ActionFillIn",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "ActionFillIn",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetActionFillIn()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "ActionFillIn",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_ActionFork:

		if all {
			switch v := interface{}(m.GetActionFork()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "ActionFork",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "ActionFork",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetActionFork()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "ActionFork",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_ActionGroupAuditFlow:

		if all {
			switch v := interface{}(m.GetActionGroupAuditFlow()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "ActionGroupAuditFlow",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "ActionGroupAuditFlow",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetActionGroupAuditFlow()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "ActionGroupAuditFlow",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_ActionListData:

		if all {
			switch v := interface{}(m.GetActionListData()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "ActionListData",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "ActionListData",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetActionListData()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "ActionListData",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_ActionMerge:

		if all {
			switch v := interface{}(m.GetActionMerge()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "ActionMerge",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "ActionMerge",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetActionMerge()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "ActionMerge",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_ActionUpdateData:

		if all {
			switch v := interface{}(m.GetActionUpdateData()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "ActionUpdateData",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "ActionUpdateData",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetActionUpdateData()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "ActionUpdateData",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_ActionCode:

		if all {
			switch v := interface{}(m.GetActionCode()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "ActionCode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "ActionCode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetActionCode()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "ActionCode",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_TriggerCron:

		if all {
			switch v := interface{}(m.GetTriggerCron()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "TriggerCron",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "TriggerCron",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTriggerCron()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "TriggerCron",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_TriggerDataEvent:

		if all {
			switch v := interface{}(m.GetTriggerDataEvent()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "TriggerDataEvent",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "TriggerDataEvent",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTriggerDataEvent()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "TriggerDataEvent",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_TriggerOrgEvent:

		if all {
			switch v := interface{}(m.GetTriggerOrgEvent()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "TriggerOrgEvent",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "TriggerOrgEvent",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTriggerOrgEvent()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "TriggerOrgEvent",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_TriggerWebhook:

		if all {
			switch v := interface{}(m.GetTriggerWebhook()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "TriggerWebhook",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "TriggerWebhook",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTriggerWebhook()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "TriggerWebhook",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_ActionFindData:

		if all {
			switch v := interface{}(m.GetActionFindData()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "ActionFindData",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "ActionFindData",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetActionFindData()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "ActionFindData",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_TriggerDateColumnCron:

		if all {
			switch v := interface{}(m.GetTriggerDateColumnCron()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "TriggerDateColumnCron",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "TriggerDateColumnCron",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTriggerDateColumnCron()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "TriggerDateColumnCron",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_TriggerUserEvent:

		if all {
			switch v := interface{}(m.GetTriggerUserEvent()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "TriggerUserEvent",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "TriggerUserEvent",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTriggerUserEvent()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "TriggerUserEvent",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_ActionMysql:

		if all {
			switch v := interface{}(m.GetActionMysql()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "ActionMysql",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "ActionMysql",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetActionMysql()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "ActionMysql",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_ActionPostgres:

		if all {
			switch v := interface{}(m.GetActionPostgres()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "ActionPostgres",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "ActionPostgres",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetActionPostgres()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "ActionPostgres",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_ActionCopyData:

		if all {
			switch v := interface{}(m.GetActionCopyData()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "ActionCopyData",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "ActionCopyData",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetActionCopyData()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "ActionCopyData",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_ActionSendEmail:

		if all {
			switch v := interface{}(m.GetActionSendEmail()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "ActionSendEmail",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "ActionSendEmail",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetActionSendEmail()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "ActionSendEmail",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_ActionSendCardFeishu:

		if all {
			switch v := interface{}(m.GetActionSendCardFeishu()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "ActionSendCardFeishu",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "ActionSendCardFeishu",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetActionSendCardFeishu()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "ActionSendCardFeishu",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_ActionSendCardDingTalk:

		if all {
			switch v := interface{}(m.GetActionSendCardDingTalk()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "ActionSendCardDingTalk",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "ActionSendCardDingTalk",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetActionSendCardDingTalk()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "ActionSendCardDingTalk",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_ActionSendCardWeCom:

		if all {
			switch v := interface{}(m.GetActionSendCardWeCom()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "ActionSendCardWeCom",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "ActionSendCardWeCom",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetActionSendCardWeCom()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "ActionSendCardWeCom",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_ActionGroupLoop:

		if all {
			switch v := interface{}(m.GetActionGroupLoop()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "ActionGroupLoop",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "ActionGroupLoop",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetActionGroupLoop()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "ActionGroupLoop",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return NodeMultiError(errors)
	}

	return nil
}

// NodeMultiError is an error wrapping multiple validation errors returned by
// Node.ValidateAll() if the designated constraints aren't met.
type NodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeMultiError) AllErrors() []error { return m }

// NodeValidationError is the validation error returned by Node.Validate if the
// designated constraints aren't met.
type NodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeValidationError) ErrorName() string { return "NodeValidationError" }

// Error satisfies the builtin error interface
func (e NodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeValidationError{}

// Validate checks the field values on Nodes with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Nodes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Nodes with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in NodesMultiError, or nil if none found.
func (m *Nodes) ValidateAll() error {
	return m.validate(true)
}

func (m *Nodes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetNodes()) < 1 {
		err := NodesValidationError{
			field:  "Nodes",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetNodes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodesValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodesValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodesValidationError{
					field:  fmt.Sprintf("Nodes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return NodesMultiError(errors)
	}

	return nil
}

// NodesMultiError is an error wrapping multiple validation errors returned by
// Nodes.ValidateAll() if the designated constraints aren't met.
type NodesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodesMultiError) AllErrors() []error { return m }

// NodesValidationError is the validation error returned by Nodes.Validate if
// the designated constraints aren't met.
type NodesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodesValidationError) ErrorName() string { return "NodesValidationError" }

// Error satisfies the builtin error interface
func (e NodesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodesValidationError{}

// Validate checks the field values on Connection with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Connection) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Connection with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConnectionMultiError, or
// nil if none found.
func (m *Connection) ValidateAll() error {
	return m.validate(true)
}

func (m *Connection) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetFromId()); l < 1 || l > 128 {
		err := ConnectionValidationError{
			field:  "FromId",
			reason: "value length must be between 1 and 128 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetFromIndex() < 0 {
		err := ConnectionValidationError{
			field:  "FromIndex",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetToId()); l < 1 || l > 128 {
		err := ConnectionValidationError{
			field:  "ToId",
			reason: "value length must be between 1 and 128 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetToIndex() < 0 {
		err := ConnectionValidationError{
			field:  "ToIndex",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ConnectionMultiError(errors)
	}

	return nil
}

// ConnectionMultiError is an error wrapping multiple validation errors
// returned by Connection.ValidateAll() if the designated constraints aren't met.
type ConnectionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConnectionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConnectionMultiError) AllErrors() []error { return m }

// ConnectionValidationError is the validation error returned by
// Connection.Validate if the designated constraints aren't met.
type ConnectionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConnectionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConnectionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConnectionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConnectionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConnectionValidationError) ErrorName() string { return "ConnectionValidationError" }

// Error satisfies the builtin error interface
func (e ConnectionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConnection.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConnectionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConnectionValidationError{}

// Validate checks the field values on Connections with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Connections) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Connections with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConnectionsMultiError, or
// nil if none found.
func (m *Connections) ValidateAll() error {
	return m.validate(true)
}

func (m *Connections) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetConnections() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConnectionsValidationError{
						field:  fmt.Sprintf("Connections[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConnectionsValidationError{
						field:  fmt.Sprintf("Connections[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConnectionsValidationError{
					field:  fmt.Sprintf("Connections[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ConnectionsMultiError(errors)
	}

	return nil
}

// ConnectionsMultiError is an error wrapping multiple validation errors
// returned by Connections.ValidateAll() if the designated constraints aren't met.
type ConnectionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConnectionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConnectionsMultiError) AllErrors() []error { return m }

// ConnectionsValidationError is the validation error returned by
// Connections.Validate if the designated constraints aren't met.
type ConnectionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConnectionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConnectionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConnectionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConnectionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConnectionsValidationError) ErrorName() string { return "ConnectionsValidationError" }

// Error satisfies the builtin error interface
func (e ConnectionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConnections.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConnectionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConnectionsValidationError{}

// Validate checks the field values on WorkflowMeta with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *WorkflowMeta) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WorkflowMeta with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in WorkflowMetaMultiError, or
// nil if none found.
func (m *WorkflowMeta) ValidateAll() error {
	return m.validate(true)
}

func (m *WorkflowMeta) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 1 || l > 20 {
		err := WorkflowMetaValidationError{
			field:  "Id",
			reason: "value length must be between 1 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetOrgId() <= 0 {
		err := WorkflowMetaValidationError{
			field:  "OrgId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetAppId()); l < 1 || l > 20 {
		err := WorkflowMetaValidationError{
			field:  "AppId",
			reason: "value length must be between 1 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 0 || l > 128 {
		err := WorkflowMetaValidationError{
			field:  "Name",
			reason: "value length must be between 0 and 128 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDesc()); l < 0 || l > 1024 {
		err := WorkflowMetaValidationError{
			field:  "Desc",
			reason: "value length must be between 0 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Active

	if l := utf8.RuneCountInString(m.GetActiveVersionId()); l < 0 || l > 20 {
		err := WorkflowMetaValidationError{
			field:  "ActiveVersionId",
			reason: "value length must be between 0 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetVersionId()); l < 1 || l > 20 {
		err := WorkflowMetaValidationError{
			field:  "VersionId",
			reason: "value length must be between 1 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for TriggerType

	// no validation rules for FailedTimes

	if m.GetCreator() < 0 {
		err := WorkflowMetaValidationError{
			field:  "Creator",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetUpdater() < 0 {
		err := WorkflowMetaValidationError{
			field:  "Updater",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetCreatedAt() < 0 {
		err := WorkflowMetaValidationError{
			field:  "CreatedAt",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetUpdatedAt() < 0 {
		err := WorkflowMetaValidationError{
			field:  "UpdatedAt",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for CreatorName

	// no validation rules for UpdaterName

	if len(errors) > 0 {
		return WorkflowMetaMultiError(errors)
	}

	return nil
}

// WorkflowMetaMultiError is an error wrapping multiple validation errors
// returned by WorkflowMeta.ValidateAll() if the designated constraints aren't met.
type WorkflowMetaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WorkflowMetaMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WorkflowMetaMultiError) AllErrors() []error { return m }

// WorkflowMetaValidationError is the validation error returned by
// WorkflowMeta.Validate if the designated constraints aren't met.
type WorkflowMetaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WorkflowMetaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WorkflowMetaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WorkflowMetaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WorkflowMetaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WorkflowMetaValidationError) ErrorName() string { return "WorkflowMetaValidationError" }

// Error satisfies the builtin error interface
func (e WorkflowMetaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWorkflowMeta.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WorkflowMetaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WorkflowMetaValidationError{}

// Validate checks the field values on Workflow with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Workflow) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Workflow with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in WorkflowMultiError, or nil
// if none found.
func (m *Workflow) ValidateAll() error {
	return m.validate(true)
}

func (m *Workflow) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 1 || l > 20 {
		err := WorkflowValidationError{
			field:  "Id",
			reason: "value length must be between 1 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetOrgId() <= 0 {
		err := WorkflowValidationError{
			field:  "OrgId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetAppId()); l < 1 || l > 20 {
		err := WorkflowValidationError{
			field:  "AppId",
			reason: "value length must be between 1 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 0 || l > 128 {
		err := WorkflowValidationError{
			field:  "Name",
			reason: "value length must be between 0 and 128 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDesc()); l < 0 || l > 1024 {
		err := WorkflowValidationError{
			field:  "Desc",
			reason: "value length must be between 0 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Active

	if l := utf8.RuneCountInString(m.GetActiveVersionId()); l < 0 || l > 20 {
		err := WorkflowValidationError{
			field:  "ActiveVersionId",
			reason: "value length must be between 0 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetVersionId()); l < 1 || l > 20 {
		err := WorkflowValidationError{
			field:  "VersionId",
			reason: "value length must be between 1 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for TriggerType

	// no validation rules for FailedTimes

	if m.GetCreator() < 0 {
		err := WorkflowValidationError{
			field:  "Creator",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetUpdater() < 0 {
		err := WorkflowValidationError{
			field:  "Updater",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetCreatedAt() < 0 {
		err := WorkflowValidationError{
			field:  "CreatedAt",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetUpdatedAt() < 0 {
		err := WorkflowValidationError{
			field:  "UpdatedAt",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for CreatorName

	// no validation rules for UpdaterName

	if len(m.GetNodes()) < 1 {
		err := WorkflowValidationError{
			field:  "Nodes",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetNodes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, WorkflowValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, WorkflowValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WorkflowValidationError{
					field:  fmt.Sprintf("Nodes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetConnections() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, WorkflowValidationError{
						field:  fmt.Sprintf("Connections[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, WorkflowValidationError{
						field:  fmt.Sprintf("Connections[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WorkflowValidationError{
					field:  fmt.Sprintf("Connections[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return WorkflowMultiError(errors)
	}

	return nil
}

// WorkflowMultiError is an error wrapping multiple validation errors returned
// by Workflow.ValidateAll() if the designated constraints aren't met.
type WorkflowMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WorkflowMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WorkflowMultiError) AllErrors() []error { return m }

// WorkflowValidationError is the validation error returned by
// Workflow.Validate if the designated constraints aren't met.
type WorkflowValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WorkflowValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WorkflowValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WorkflowValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WorkflowValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WorkflowValidationError) ErrorName() string { return "WorkflowValidationError" }

// Error satisfies the builtin error interface
func (e WorkflowValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWorkflow.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WorkflowValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WorkflowValidationError{}

// Validate checks the field values on WorkflowInput with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *WorkflowInput) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WorkflowInput with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in WorkflowInputMultiError, or
// nil if none found.
func (m *WorkflowInput) ValidateAll() error {
	return m.validate(true)
}

func (m *WorkflowInput) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 0 || l > 128 {
		err := WorkflowInputValidationError{
			field:  "Name",
			reason: "value length must be between 0 and 128 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDesc()); l < 0 || l > 1024 {
		err := WorkflowInputValidationError{
			field:  "Desc",
			reason: "value length must be between 0 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetNodes()) < 1 {
		err := WorkflowInputValidationError{
			field:  "Nodes",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetNodes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, WorkflowInputValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, WorkflowInputValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WorkflowInputValidationError{
					field:  fmt.Sprintf("Nodes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetConnections() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, WorkflowInputValidationError{
						field:  fmt.Sprintf("Connections[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, WorkflowInputValidationError{
						field:  fmt.Sprintf("Connections[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WorkflowInputValidationError{
					field:  fmt.Sprintf("Connections[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return WorkflowInputMultiError(errors)
	}

	return nil
}

// WorkflowInputMultiError is an error wrapping multiple validation errors
// returned by WorkflowInput.ValidateAll() if the designated constraints
// aren't met.
type WorkflowInputMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WorkflowInputMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WorkflowInputMultiError) AllErrors() []error { return m }

// WorkflowInputValidationError is the validation error returned by
// WorkflowInput.Validate if the designated constraints aren't met.
type WorkflowInputValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WorkflowInputValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WorkflowInputValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WorkflowInputValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WorkflowInputValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WorkflowInputValidationError) ErrorName() string { return "WorkflowInputValidationError" }

// Error satisfies the builtin error interface
func (e WorkflowInputValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWorkflowInput.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WorkflowInputValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WorkflowInputValidationError{}

// Validate checks the field values on ExecutionMeta with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ExecutionMeta) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExecutionMeta with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ExecutionMetaMultiError, or
// nil if none found.
func (m *ExecutionMeta) ValidateAll() error {
	return m.validate(true)
}

func (m *ExecutionMeta) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 1 || l > 20 {
		err := ExecutionMetaValidationError{
			field:  "Id",
			reason: "value length must be between 1 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetWorkflowId()); l < 1 || l > 20 {
		err := ExecutionMetaValidationError{
			field:  "WorkflowId",
			reason: "value length must be between 1 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Succeed

	// no validation rules for StartedAt

	// no validation rules for StoppedAt

	// no validation rules for Finished

	// no validation rules for Status

	if len(errors) > 0 {
		return ExecutionMetaMultiError(errors)
	}

	return nil
}

// ExecutionMetaMultiError is an error wrapping multiple validation errors
// returned by ExecutionMeta.ValidateAll() if the designated constraints
// aren't met.
type ExecutionMetaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExecutionMetaMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExecutionMetaMultiError) AllErrors() []error { return m }

// ExecutionMetaValidationError is the validation error returned by
// ExecutionMeta.Validate if the designated constraints aren't met.
type ExecutionMetaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExecutionMetaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExecutionMetaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExecutionMetaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExecutionMetaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExecutionMetaValidationError) ErrorName() string { return "ExecutionMetaValidationError" }

// Error satisfies the builtin error interface
func (e ExecutionMetaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExecutionMeta.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExecutionMetaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExecutionMetaValidationError{}

// Validate checks the field values on Execution with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Execution) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Execution with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ExecutionMultiError, or nil
// if none found.
func (m *Execution) ValidateAll() error {
	return m.validate(true)
}

func (m *Execution) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 1 || l > 20 {
		err := ExecutionValidationError{
			field:  "Id",
			reason: "value length must be between 1 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetWorkflowId()); l < 1 || l > 20 {
		err := ExecutionValidationError{
			field:  "WorkflowId",
			reason: "value length must be between 1 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Succeed

	// no validation rules for StartedAt

	// no validation rules for StoppedAt

	for idx, item := range m.GetNodes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExecutionValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExecutionValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExecutionValidationError{
					field:  fmt.Sprintf("Nodes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(m.GetWorkflowNodes()) < 1 {
		err := ExecutionValidationError{
			field:  "WorkflowNodes",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetWorkflowNodes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExecutionValidationError{
						field:  fmt.Sprintf("WorkflowNodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExecutionValidationError{
						field:  fmt.Sprintf("WorkflowNodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExecutionValidationError{
					field:  fmt.Sprintf("WorkflowNodes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Finished

	// no validation rules for Status

	if len(errors) > 0 {
		return ExecutionMultiError(errors)
	}

	return nil
}

// ExecutionMultiError is an error wrapping multiple validation errors returned
// by Execution.ValidateAll() if the designated constraints aren't met.
type ExecutionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExecutionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExecutionMultiError) AllErrors() []error { return m }

// ExecutionValidationError is the validation error returned by
// Execution.Validate if the designated constraints aren't met.
type ExecutionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExecutionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExecutionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExecutionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExecutionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExecutionValidationError) ErrorName() string { return "ExecutionValidationError" }

// Error satisfies the builtin error interface
func (e ExecutionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExecution.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExecutionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExecutionValidationError{}

// Validate checks the field values on NodeExecution with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NodeExecution) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeExecution with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NodeExecutionMultiError, or
// nil if none found.
func (m *NodeExecution) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeExecution) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 1 || l > 20 {
		err := NodeExecutionValidationError{
			field:  "Id",
			reason: "value length must be between 1 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Succeed

	// no validation rules for ExecutionTime

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeExecutionValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeExecutionValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeExecutionValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PreviousId

	// no validation rules for PreviousRunIdx

	// no validation rules for StartTime

	// no validation rules for RunIdx

	// no validation rules for Finished

	// no validation rules for Waiting

	if len(errors) > 0 {
		return NodeExecutionMultiError(errors)
	}

	return nil
}

// NodeExecutionMultiError is an error wrapping multiple validation errors
// returned by NodeExecution.ValidateAll() if the designated constraints
// aren't met.
type NodeExecutionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeExecutionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeExecutionMultiError) AllErrors() []error { return m }

// NodeExecutionValidationError is the validation error returned by
// NodeExecution.Validate if the designated constraints aren't met.
type NodeExecutionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeExecutionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeExecutionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeExecutionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeExecutionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeExecutionValidationError) ErrorName() string { return "NodeExecutionValidationError" }

// Error satisfies the builtin error interface
func (e NodeExecutionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeExecution.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeExecutionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeExecutionValidationError{}

// Validate checks the field values on Todo with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Todo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Todo with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TodoMultiError, or nil if none found.
func (m *Todo) ValidateAll() error {
	return m.validate(true)
}

func (m *Todo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 1 || l > 20 {
		err := TodoValidationError{
			field:  "Id",
			reason: "value length must be between 1 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetOrgId() <= 0 {
		err := TodoValidationError{
			field:  "OrgId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetAppId()); l < 1 || l > 20 {
		err := TodoValidationError{
			field:  "AppId",
			reason: "value length must be between 1 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetTableId()); l < 1 || l > 20 {
		err := TodoValidationError{
			field:  "TableId",
			reason: "value length must be between 1 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetIssueId() <= 0 {
		err := TodoValidationError{
			field:  "IssueId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetWorkflowId()); l < 1 || l > 20 {
		err := TodoValidationError{
			field:  "WorkflowId",
			reason: "value length must be between 1 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetWorkflowName()); l < 0 || l > 128 {
		err := TodoValidationError{
			field:  "WorkflowName",
			reason: "value length must be between 0 and 128 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetAuditFlowName()); l < 0 || l > 128 {
		err := TodoValidationError{
			field:  "AuditFlowName",
			reason: "value length must be between 0 and 128 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetExecutionId() <= 0 {
		err := TodoValidationError{
			field:  "ExecutionId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetTriggerUserId() <= 0 {
		err := TodoValidationError{
			field:  "TriggerUserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for AllowWithdrawByTrigger

	// no validation rules for AllowUrgeByTrigger

	// no validation rules for Type

	// no validation rules for Status

	{
		sorted_keys := make([]int64, len(m.GetOperators()))
		i := 0
		for key := range m.GetOperators() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetOperators()[key]
			_ = val

			// no validation rules for Operators[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, TodoValidationError{
							field:  fmt.Sprintf("Operators[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, TodoValidationError{
							field:  fmt.Sprintf("Operators[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return TodoValidationError{
						field:  fmt.Sprintf("Operators[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if m.GetCreator() < 0 {
		err := TodoValidationError{
			field:  "Creator",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetUpdater() < 0 {
		err := TodoValidationError{
			field:  "Updater",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetCreatedAt() < 0 {
		err := TodoValidationError{
			field:  "CreatedAt",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetUpdatedAt() < 0 {
		err := TodoValidationError{
			field:  "UpdatedAt",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetAuditFlowId()); l < 1 || l > 128 {
		err := TodoValidationError{
			field:  "AuditFlowId",
			reason: "value length must be between 1 and 128 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for IssueTitle

	switch m.Parameters.(type) {

	case *Todo_TodoAudit:

		if all {
			switch v := interface{}(m.GetTodoAudit()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TodoValidationError{
						field:  "TodoAudit",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TodoValidationError{
						field:  "TodoAudit",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTodoAudit()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TodoValidationError{
					field:  "TodoAudit",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Todo_TodoFillIn:

		if all {
			switch v := interface{}(m.GetTodoFillIn()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TodoValidationError{
						field:  "TodoFillIn",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TodoValidationError{
						field:  "TodoFillIn",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTodoFillIn()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TodoValidationError{
					field:  "TodoFillIn",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TodoMultiError(errors)
	}

	return nil
}

// TodoMultiError is an error wrapping multiple validation errors returned by
// Todo.ValidateAll() if the designated constraints aren't met.
type TodoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TodoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TodoMultiError) AllErrors() []error { return m }

// TodoValidationError is the validation error returned by Todo.Validate if the
// designated constraints aren't met.
type TodoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TodoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TodoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TodoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TodoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TodoValidationError) ErrorName() string { return "TodoValidationError" }

// Error satisfies the builtin error interface
func (e TodoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTodo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TodoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TodoValidationError{}

// Validate checks the field values on TodoStat with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TodoStat) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TodoStat with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TodoStatMultiError, or nil
// if none found.
func (m *TodoStat) ValidateAll() error {
	return m.validate(true)
}

func (m *TodoStat) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	if m.GetTotal() < 0 {
		err := TodoStatValidationError{
			field:  "Total",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return TodoStatMultiError(errors)
	}

	return nil
}

// TodoStatMultiError is an error wrapping multiple validation errors returned
// by TodoStat.ValidateAll() if the designated constraints aren't met.
type TodoStatMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TodoStatMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TodoStatMultiError) AllErrors() []error { return m }

// TodoStatValidationError is the validation error returned by
// TodoStat.Validate if the designated constraints aren't met.
type TodoStatValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TodoStatValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TodoStatValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TodoStatValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TodoStatValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TodoStatValidationError) ErrorName() string { return "TodoStatValidationError" }

// Error satisfies the builtin error interface
func (e TodoStatValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTodoStat.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TodoStatValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TodoStatValidationError{}

// Validate checks the field values on TodoResult with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TodoResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TodoResult with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TodoResultMultiError, or
// nil if none found.
func (m *TodoResult) ValidateAll() error {
	return m.validate(true)
}

func (m *TodoResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Op

	if l := utf8.RuneCountInString(m.GetMsg()); l < 0 || l > 1024 {
		err := TodoResultValidationError{
			field:  "Msg",
			reason: "value length must be between 0 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetOpAt() < 0 {
		err := TodoResultValidationError{
			field:  "OpAt",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return TodoResultMultiError(errors)
	}

	return nil
}

// TodoResultMultiError is an error wrapping multiple validation errors
// returned by TodoResult.ValidateAll() if the designated constraints aren't met.
type TodoResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TodoResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TodoResultMultiError) AllErrors() []error { return m }

// TodoResultValidationError is the validation error returned by
// TodoResult.Validate if the designated constraints aren't met.
type TodoResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TodoResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TodoResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TodoResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TodoResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TodoResultValidationError) ErrorName() string { return "TodoResultValidationError" }

// Error satisfies the builtin error interface
func (e TodoResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTodoResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TodoResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TodoResultValidationError{}

// Validate checks the field values on ParameterTodoAudit with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ParameterTodoAudit) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParameterTodoAudit with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ParameterTodoAuditMultiError, or nil if none found.
func (m *ParameterTodoAudit) ValidateAll() error {
	return m.validate(true)
}

func (m *ParameterTodoAudit) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SignMode

	for idx, item := range m.GetFormSettings() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ParameterTodoAuditValidationError{
						field:  fmt.Sprintf("FormSettings[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ParameterTodoAuditValidationError{
						field:  fmt.Sprintf("FormSettings[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ParameterTodoAuditValidationError{
					field:  fmt.Sprintf("FormSettings[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ParameterTodoAuditMultiError(errors)
	}

	return nil
}

// ParameterTodoAuditMultiError is an error wrapping multiple validation errors
// returned by ParameterTodoAudit.ValidateAll() if the designated constraints
// aren't met.
type ParameterTodoAuditMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParameterTodoAuditMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParameterTodoAuditMultiError) AllErrors() []error { return m }

// ParameterTodoAuditValidationError is the validation error returned by
// ParameterTodoAudit.Validate if the designated constraints aren't met.
type ParameterTodoAuditValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParameterTodoAuditValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParameterTodoAuditValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParameterTodoAuditValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParameterTodoAuditValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParameterTodoAuditValidationError) ErrorName() string {
	return "ParameterTodoAuditValidationError"
}

// Error satisfies the builtin error interface
func (e ParameterTodoAuditValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParameterTodoAudit.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParameterTodoAuditValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParameterTodoAuditValidationError{}

// Validate checks the field values on ParameterTodoFillIn with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ParameterTodoFillIn) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParameterTodoFillIn with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ParameterTodoFillInMultiError, or nil if none found.
func (m *ParameterTodoFillIn) ValidateAll() error {
	return m.validate(true)
}

func (m *ParameterTodoFillIn) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetFormSettings() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ParameterTodoFillInValidationError{
						field:  fmt.Sprintf("FormSettings[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ParameterTodoFillInValidationError{
						field:  fmt.Sprintf("FormSettings[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ParameterTodoFillInValidationError{
					field:  fmt.Sprintf("FormSettings[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ParameterTodoFillInMultiError(errors)
	}

	return nil
}

// ParameterTodoFillInMultiError is an error wrapping multiple validation
// errors returned by ParameterTodoFillIn.ValidateAll() if the designated
// constraints aren't met.
type ParameterTodoFillInMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParameterTodoFillInMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParameterTodoFillInMultiError) AllErrors() []error { return m }

// ParameterTodoFillInValidationError is the validation error returned by
// ParameterTodoFillIn.Validate if the designated constraints aren't met.
type ParameterTodoFillInValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParameterTodoFillInValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParameterTodoFillInValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParameterTodoFillInValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParameterTodoFillInValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParameterTodoFillInValidationError) ErrorName() string {
	return "ParameterTodoFillInValidationError"
}

// Error satisfies the builtin error interface
func (e ParameterTodoFillInValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParameterTodoFillIn.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParameterTodoFillInValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParameterTodoFillInValidationError{}

// Validate checks the field values on ParameterActionCreateData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ParameterActionCreateData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParameterActionCreateData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ParameterActionCreateDataMultiError, or nil if none found.
func (m *ParameterActionCreateData) ValidateAll() error {
	return m.validate(true)
}

func (m *ParameterActionCreateData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AppId

	// no validation rules for TableId

	for idx, item := range m.GetKeyValues() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ParameterActionCreateDataValidationError{
						field:  fmt.Sprintf("KeyValues[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ParameterActionCreateDataValidationError{
						field:  fmt.Sprintf("KeyValues[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ParameterActionCreateDataValidationError{
					field:  fmt.Sprintf("KeyValues[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ParameterActionCreateDataMultiError(errors)
	}

	return nil
}

// ParameterActionCreateDataMultiError is an error wrapping multiple validation
// errors returned by ParameterActionCreateData.ValidateAll() if the
// designated constraints aren't met.
type ParameterActionCreateDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParameterActionCreateDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParameterActionCreateDataMultiError) AllErrors() []error { return m }

// ParameterActionCreateDataValidationError is the validation error returned by
// ParameterActionCreateData.Validate if the designated constraints aren't met.
type ParameterActionCreateDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParameterActionCreateDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParameterActionCreateDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParameterActionCreateDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParameterActionCreateDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParameterActionCreateDataValidationError) ErrorName() string {
	return "ParameterActionCreateDataValidationError"
}

// Error satisfies the builtin error interface
func (e ParameterActionCreateDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParameterActionCreateData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParameterActionCreateDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParameterActionCreateDataValidationError{}

// Validate checks the field values on ParameterActionCopyData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ParameterActionCopyData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParameterActionCopyData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ParameterActionCopyDataMultiError, or nil if none found.
func (m *ParameterActionCopyData) ValidateAll() error {
	return m.validate(true)
}

func (m *ParameterActionCopyData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AppId

	// no validation rules for TableId

	if all {
		switch v := interface{}(m.GetSource()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ParameterActionCopyDataValidationError{
					field:  "Source",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ParameterActionCopyDataValidationError{
					field:  "Source",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSource()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ParameterActionCopyDataValidationError{
				field:  "Source",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetKeyValues() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ParameterActionCopyDataValidationError{
						field:  fmt.Sprintf("KeyValues[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ParameterActionCopyDataValidationError{
						field:  fmt.Sprintf("KeyValues[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ParameterActionCopyDataValidationError{
					field:  fmt.Sprintf("KeyValues[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for StaticCopy

	if len(errors) > 0 {
		return ParameterActionCopyDataMultiError(errors)
	}

	return nil
}

// ParameterActionCopyDataMultiError is an error wrapping multiple validation
// errors returned by ParameterActionCopyData.ValidateAll() if the designated
// constraints aren't met.
type ParameterActionCopyDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParameterActionCopyDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParameterActionCopyDataMultiError) AllErrors() []error { return m }

// ParameterActionCopyDataValidationError is the validation error returned by
// ParameterActionCopyData.Validate if the designated constraints aren't met.
type ParameterActionCopyDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParameterActionCopyDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParameterActionCopyDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParameterActionCopyDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParameterActionCopyDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParameterActionCopyDataValidationError) ErrorName() string {
	return "ParameterActionCopyDataValidationError"
}

// Error satisfies the builtin error interface
func (e ParameterActionCopyDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParameterActionCopyData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParameterActionCopyDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParameterActionCopyDataValidationError{}

// Validate checks the field values on ParameterActionUpdateData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ParameterActionUpdateData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParameterActionUpdateData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ParameterActionUpdateDataMultiError, or nil if none found.
func (m *ParameterActionUpdateData) ValidateAll() error {
	return m.validate(true)
}

func (m *ParameterActionUpdateData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSource()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ParameterActionUpdateDataValidationError{
					field:  "Source",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ParameterActionUpdateDataValidationError{
					field:  "Source",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSource()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ParameterActionUpdateDataValidationError{
				field:  "Source",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetKeyValues() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ParameterActionUpdateDataValidationError{
						field:  fmt.Sprintf("KeyValues[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ParameterActionUpdateDataValidationError{
						field:  fmt.Sprintf("KeyValues[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ParameterActionUpdateDataValidationError{
					field:  fmt.Sprintf("KeyValues[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ParameterActionUpdateDataMultiError(errors)
	}

	return nil
}

// ParameterActionUpdateDataMultiError is an error wrapping multiple validation
// errors returned by ParameterActionUpdateData.ValidateAll() if the
// designated constraints aren't met.
type ParameterActionUpdateDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParameterActionUpdateDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParameterActionUpdateDataMultiError) AllErrors() []error { return m }

// ParameterActionUpdateDataValidationError is the validation error returned by
// ParameterActionUpdateData.Validate if the designated constraints aren't met.
type ParameterActionUpdateDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParameterActionUpdateDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParameterActionUpdateDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParameterActionUpdateDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParameterActionUpdateDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParameterActionUpdateDataValidationError) ErrorName() string {
	return "ParameterActionUpdateDataValidationError"
}

// Error satisfies the builtin error interface
func (e ParameterActionUpdateDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParameterActionUpdateData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParameterActionUpdateDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParameterActionUpdateDataValidationError{}

// Validate checks the field values on ParameterActionListData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ParameterActionListData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParameterActionListData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ParameterActionListDataMultiError, or nil if none found.
func (m *ParameterActionListData) ValidateAll() error {
	return m.validate(true)
}

func (m *ParameterActionListData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AppId

	// no validation rules for TableId

	if all {
		switch v := interface{}(m.GetCondition()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ParameterActionListDataValidationError{
					field:  "Condition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ParameterActionListDataValidationError{
					field:  "Condition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCondition()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ParameterActionListDataValidationError{
				field:  "Condition",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetOrders() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ParameterActionListDataValidationError{
						field:  fmt.Sprintf("Orders[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ParameterActionListDataValidationError{
						field:  fmt.Sprintf("Orders[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ParameterActionListDataValidationError{
					field:  fmt.Sprintf("Orders[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for IncludeChildren

	if m.GetLimit() <= 0 {
		err := ParameterActionListDataValidationError{
			field:  "Limit",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ParameterActionListDataMultiError(errors)
	}

	return nil
}

// ParameterActionListDataMultiError is an error wrapping multiple validation
// errors returned by ParameterActionListData.ValidateAll() if the designated
// constraints aren't met.
type ParameterActionListDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParameterActionListDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParameterActionListDataMultiError) AllErrors() []error { return m }

// ParameterActionListDataValidationError is the validation error returned by
// ParameterActionListData.Validate if the designated constraints aren't met.
type ParameterActionListDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParameterActionListDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParameterActionListDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParameterActionListDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParameterActionListDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParameterActionListDataValidationError) ErrorName() string {
	return "ParameterActionListDataValidationError"
}

// Error satisfies the builtin error interface
func (e ParameterActionListDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParameterActionListData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParameterActionListDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParameterActionListDataValidationError{}

// Validate checks the field values on ParameterActionFindData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ParameterActionFindData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParameterActionFindData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ParameterActionFindDataMultiError, or nil if none found.
func (m *ParameterActionFindData) ValidateAll() error {
	return m.validate(true)
}

func (m *ParameterActionFindData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AppId

	// no validation rules for TableId

	if all {
		switch v := interface{}(m.GetCondition()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ParameterActionFindDataValidationError{
					field:  "Condition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ParameterActionFindDataValidationError{
					field:  "Condition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCondition()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ParameterActionFindDataValidationError{
				field:  "Condition",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetOrders() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ParameterActionFindDataValidationError{
						field:  fmt.Sprintf("Orders[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ParameterActionFindDataValidationError{
						field:  fmt.Sprintf("Orders[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ParameterActionFindDataValidationError{
					field:  fmt.Sprintf("Orders[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ParameterActionFindDataMultiError(errors)
	}

	return nil
}

// ParameterActionFindDataMultiError is an error wrapping multiple validation
// errors returned by ParameterActionFindData.ValidateAll() if the designated
// constraints aren't met.
type ParameterActionFindDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParameterActionFindDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParameterActionFindDataMultiError) AllErrors() []error { return m }

// ParameterActionFindDataValidationError is the validation error returned by
// ParameterActionFindData.Validate if the designated constraints aren't met.
type ParameterActionFindDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParameterActionFindDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParameterActionFindDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParameterActionFindDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParameterActionFindDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParameterActionFindDataValidationError) ErrorName() string {
	return "ParameterActionFindDataValidationError"
}

// Error satisfies the builtin error interface
func (e ParameterActionFindDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParameterActionFindData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParameterActionFindDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParameterActionFindDataValidationError{}

// Validate checks the field values on ParameterActionAudit with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ParameterActionAudit) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParameterActionAudit with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ParameterActionAuditMultiError, or nil if none found.
func (m *ParameterActionAudit) ValidateAll() error {
	return m.validate(true)
}

func (m *ParameterActionAudit) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetOperators() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ParameterActionAuditValidationError{
						field:  fmt.Sprintf("Operators[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ParameterActionAuditValidationError{
						field:  fmt.Sprintf("Operators[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ParameterActionAuditValidationError{
					field:  fmt.Sprintf("Operators[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for SignMode

	for idx, item := range m.GetFormSettings() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ParameterActionAuditValidationError{
						field:  fmt.Sprintf("FormSettings[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ParameterActionAuditValidationError{
						field:  fmt.Sprintf("FormSettings[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ParameterActionAuditValidationError{
					field:  fmt.Sprintf("FormSettings[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ParameterActionAuditMultiError(errors)
	}

	return nil
}

// ParameterActionAuditMultiError is an error wrapping multiple validation
// errors returned by ParameterActionAudit.ValidateAll() if the designated
// constraints aren't met.
type ParameterActionAuditMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParameterActionAuditMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParameterActionAuditMultiError) AllErrors() []error { return m }

// ParameterActionAuditValidationError is the validation error returned by
// ParameterActionAudit.Validate if the designated constraints aren't met.
type ParameterActionAuditValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParameterActionAuditValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParameterActionAuditValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParameterActionAuditValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParameterActionAuditValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParameterActionAuditValidationError) ErrorName() string {
	return "ParameterActionAuditValidationError"
}

// Error satisfies the builtin error interface
func (e ParameterActionAuditValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParameterActionAudit.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParameterActionAuditValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParameterActionAuditValidationError{}

// Validate checks the field values on ParameterActionFillIn with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ParameterActionFillIn) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParameterActionFillIn with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ParameterActionFillInMultiError, or nil if none found.
func (m *ParameterActionFillIn) ValidateAll() error {
	return m.validate(true)
}

func (m *ParameterActionFillIn) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetOperators() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ParameterActionFillInValidationError{
						field:  fmt.Sprintf("Operators[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ParameterActionFillInValidationError{
						field:  fmt.Sprintf("Operators[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ParameterActionFillInValidationError{
					field:  fmt.Sprintf("Operators[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetFormSettings() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ParameterActionFillInValidationError{
						field:  fmt.Sprintf("FormSettings[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ParameterActionFillInValidationError{
						field:  fmt.Sprintf("FormSettings[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ParameterActionFillInValidationError{
					field:  fmt.Sprintf("FormSettings[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ParameterActionFillInMultiError(errors)
	}

	return nil
}

// ParameterActionFillInMultiError is an error wrapping multiple validation
// errors returned by ParameterActionFillIn.ValidateAll() if the designated
// constraints aren't met.
type ParameterActionFillInMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParameterActionFillInMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParameterActionFillInMultiError) AllErrors() []error { return m }

// ParameterActionFillInValidationError is the validation error returned by
// ParameterActionFillIn.Validate if the designated constraints aren't met.
type ParameterActionFillInValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParameterActionFillInValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParameterActionFillInValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParameterActionFillInValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParameterActionFillInValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParameterActionFillInValidationError) ErrorName() string {
	return "ParameterActionFillInValidationError"
}

// Error satisfies the builtin error interface
func (e ParameterActionFillInValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParameterActionFillIn.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParameterActionFillInValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParameterActionFillInValidationError{}

// Validate checks the field values on ParameterActionFork with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ParameterActionFork) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParameterActionFork with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ParameterActionForkMultiError, or nil if none found.
func (m *ParameterActionFork) ValidateAll() error {
	return m.validate(true)
}

func (m *ParameterActionFork) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	for idx, item := range m.GetFilters() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ParameterActionForkValidationError{
						field:  fmt.Sprintf("Filters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ParameterActionForkValidationError{
						field:  fmt.Sprintf("Filters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ParameterActionForkValidationError{
					field:  fmt.Sprintf("Filters[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ParameterActionForkMultiError(errors)
	}

	return nil
}

// ParameterActionForkMultiError is an error wrapping multiple validation
// errors returned by ParameterActionFork.ValidateAll() if the designated
// constraints aren't met.
type ParameterActionForkMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParameterActionForkMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParameterActionForkMultiError) AllErrors() []error { return m }

// ParameterActionForkValidationError is the validation error returned by
// ParameterActionFork.Validate if the designated constraints aren't met.
type ParameterActionForkValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParameterActionForkValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParameterActionForkValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParameterActionForkValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParameterActionForkValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParameterActionForkValidationError) ErrorName() string {
	return "ParameterActionForkValidationError"
}

// Error satisfies the builtin error interface
func (e ParameterActionForkValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParameterActionFork.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParameterActionForkValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParameterActionForkValidationError{}

// Validate checks the field values on ParameterActionGroupAuditFlow with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ParameterActionGroupAuditFlow) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParameterActionGroupAuditFlow with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ParameterActionGroupAuditFlowMultiError, or nil if none found.
func (m *ParameterActionGroupAuditFlow) ValidateAll() error {
	return m.validate(true)
}

func (m *ParameterActionGroupAuditFlow) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetNodes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ParameterActionGroupAuditFlowValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ParameterActionGroupAuditFlowValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ParameterActionGroupAuditFlowValidationError{
					field:  fmt.Sprintf("Nodes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetConnections() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ParameterActionGroupAuditFlowValidationError{
						field:  fmt.Sprintf("Connections[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ParameterActionGroupAuditFlowValidationError{
						field:  fmt.Sprintf("Connections[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ParameterActionGroupAuditFlowValidationError{
					field:  fmt.Sprintf("Connections[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetSetting()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ParameterActionGroupAuditFlowValidationError{
					field:  "Setting",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ParameterActionGroupAuditFlowValidationError{
					field:  "Setting",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSetting()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ParameterActionGroupAuditFlowValidationError{
				field:  "Setting",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ParameterActionGroupAuditFlowMultiError(errors)
	}

	return nil
}

// ParameterActionGroupAuditFlowMultiError is an error wrapping multiple
// validation errors returned by ParameterActionGroupAuditFlow.ValidateAll()
// if the designated constraints aren't met.
type ParameterActionGroupAuditFlowMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParameterActionGroupAuditFlowMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParameterActionGroupAuditFlowMultiError) AllErrors() []error { return m }

// ParameterActionGroupAuditFlowValidationError is the validation error
// returned by ParameterActionGroupAuditFlow.Validate if the designated
// constraints aren't met.
type ParameterActionGroupAuditFlowValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParameterActionGroupAuditFlowValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParameterActionGroupAuditFlowValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParameterActionGroupAuditFlowValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParameterActionGroupAuditFlowValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParameterActionGroupAuditFlowValidationError) ErrorName() string {
	return "ParameterActionGroupAuditFlowValidationError"
}

// Error satisfies the builtin error interface
func (e ParameterActionGroupAuditFlowValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParameterActionGroupAuditFlow.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParameterActionGroupAuditFlowValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParameterActionGroupAuditFlowValidationError{}

// Validate checks the field values on ParameterActionGroupSettingAuditFlow
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ParameterActionGroupSettingAuditFlow) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParameterActionGroupSettingAuditFlow
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ParameterActionGroupSettingAuditFlowMultiError, or nil if none found.
func (m *ParameterActionGroupSettingAuditFlow) ValidateAll() error {
	return m.validate(true)
}

func (m *ParameterActionGroupSettingAuditFlow) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSource()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ParameterActionGroupSettingAuditFlowValidationError{
					field:  "Source",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ParameterActionGroupSettingAuditFlowValidationError{
					field:  "Source",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSource()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ParameterActionGroupSettingAuditFlowValidationError{
				field:  "Source",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTrigger()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ParameterActionGroupSettingAuditFlowValidationError{
					field:  "Trigger",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ParameterActionGroupSettingAuditFlowValidationError{
					field:  "Trigger",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTrigger()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ParameterActionGroupSettingAuditFlowValidationError{
				field:  "Trigger",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for AllowWithdrawByTrigger

	// no validation rules for AllowUrgeByTrigger

	if len(errors) > 0 {
		return ParameterActionGroupSettingAuditFlowMultiError(errors)
	}

	return nil
}

// ParameterActionGroupSettingAuditFlowMultiError is an error wrapping multiple
// validation errors returned by
// ParameterActionGroupSettingAuditFlow.ValidateAll() if the designated
// constraints aren't met.
type ParameterActionGroupSettingAuditFlowMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParameterActionGroupSettingAuditFlowMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParameterActionGroupSettingAuditFlowMultiError) AllErrors() []error { return m }

// ParameterActionGroupSettingAuditFlowValidationError is the validation error
// returned by ParameterActionGroupSettingAuditFlow.Validate if the designated
// constraints aren't met.
type ParameterActionGroupSettingAuditFlowValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParameterActionGroupSettingAuditFlowValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParameterActionGroupSettingAuditFlowValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParameterActionGroupSettingAuditFlowValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParameterActionGroupSettingAuditFlowValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParameterActionGroupSettingAuditFlowValidationError) ErrorName() string {
	return "ParameterActionGroupSettingAuditFlowValidationError"
}

// Error satisfies the builtin error interface
func (e ParameterActionGroupSettingAuditFlowValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParameterActionGroupSettingAuditFlow.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParameterActionGroupSettingAuditFlowValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParameterActionGroupSettingAuditFlowValidationError{}

// Validate checks the field values on ParameterActionGroupLoop with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ParameterActionGroupLoop) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParameterActionGroupLoop with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ParameterActionGroupLoopMultiError, or nil if none found.
func (m *ParameterActionGroupLoop) ValidateAll() error {
	return m.validate(true)
}

func (m *ParameterActionGroupLoop) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetNodes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ParameterActionGroupLoopValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ParameterActionGroupLoopValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ParameterActionGroupLoopValidationError{
					field:  fmt.Sprintf("Nodes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetConnections() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ParameterActionGroupLoopValidationError{
						field:  fmt.Sprintf("Connections[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ParameterActionGroupLoopValidationError{
						field:  fmt.Sprintf("Connections[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ParameterActionGroupLoopValidationError{
					field:  fmt.Sprintf("Connections[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetSource()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ParameterActionGroupLoopValidationError{
					field:  "Source",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ParameterActionGroupLoopValidationError{
					field:  "Source",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSource()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ParameterActionGroupLoopValidationError{
				field:  "Source",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ParameterActionGroupLoopMultiError(errors)
	}

	return nil
}

// ParameterActionGroupLoopMultiError is an error wrapping multiple validation
// errors returned by ParameterActionGroupLoop.ValidateAll() if the designated
// constraints aren't met.
type ParameterActionGroupLoopMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParameterActionGroupLoopMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParameterActionGroupLoopMultiError) AllErrors() []error { return m }

// ParameterActionGroupLoopValidationError is the validation error returned by
// ParameterActionGroupLoop.Validate if the designated constraints aren't met.
type ParameterActionGroupLoopValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParameterActionGroupLoopValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParameterActionGroupLoopValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParameterActionGroupLoopValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParameterActionGroupLoopValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParameterActionGroupLoopValidationError) ErrorName() string {
	return "ParameterActionGroupLoopValidationError"
}

// Error satisfies the builtin error interface
func (e ParameterActionGroupLoopValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParameterActionGroupLoop.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParameterActionGroupLoopValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParameterActionGroupLoopValidationError{}

// Validate checks the field values on ParameterActionMerge with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ParameterActionMerge) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParameterActionMerge with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ParameterActionMergeMultiError, or nil if none found.
func (m *ParameterActionMerge) ValidateAll() error {
	return m.validate(true)
}

func (m *ParameterActionMerge) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetForkNode()); l < 1 || l > 128 {
		err := ParameterActionMergeValidationError{
			field:  "ForkNode",
			reason: "value length must be between 1 and 128 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ParameterActionMergeMultiError(errors)
	}

	return nil
}

// ParameterActionMergeMultiError is an error wrapping multiple validation
// errors returned by ParameterActionMerge.ValidateAll() if the designated
// constraints aren't met.
type ParameterActionMergeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParameterActionMergeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParameterActionMergeMultiError) AllErrors() []error { return m }

// ParameterActionMergeValidationError is the validation error returned by
// ParameterActionMerge.Validate if the designated constraints aren't met.
type ParameterActionMergeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParameterActionMergeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParameterActionMergeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParameterActionMergeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParameterActionMergeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParameterActionMergeValidationError) ErrorName() string {
	return "ParameterActionMergeValidationError"
}

// Error satisfies the builtin error interface
func (e ParameterActionMergeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParameterActionMerge.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParameterActionMergeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParameterActionMergeValidationError{}

// Validate checks the field values on ParameterActionCode with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ParameterActionCode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParameterActionCode with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ParameterActionCodeMultiError, or nil if none found.
func (m *ParameterActionCode) ValidateAll() error {
	return m.validate(true)
}

func (m *ParameterActionCode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCode()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ParameterActionCodeValidationError{
					field:  "Code",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ParameterActionCodeValidationError{
					field:  "Code",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCode()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ParameterActionCodeValidationError{
				field:  "Code",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ParameterActionCodeMultiError(errors)
	}

	return nil
}

// ParameterActionCodeMultiError is an error wrapping multiple validation
// errors returned by ParameterActionCode.ValidateAll() if the designated
// constraints aren't met.
type ParameterActionCodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParameterActionCodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParameterActionCodeMultiError) AllErrors() []error { return m }

// ParameterActionCodeValidationError is the validation error returned by
// ParameterActionCode.Validate if the designated constraints aren't met.
type ParameterActionCodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParameterActionCodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParameterActionCodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParameterActionCodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParameterActionCodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParameterActionCodeValidationError) ErrorName() string {
	return "ParameterActionCodeValidationError"
}

// Error satisfies the builtin error interface
func (e ParameterActionCodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParameterActionCode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParameterActionCodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParameterActionCodeValidationError{}

// Validate checks the field values on ParameterTriggerCron with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ParameterTriggerCron) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParameterTriggerCron with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ParameterTriggerCronMultiError, or nil if none found.
func (m *ParameterTriggerCron) ValidateAll() error {
	return m.validate(true)
}

func (m *ParameterTriggerCron) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	switch m.Parameters.(type) {

	case *ParameterTriggerCron_Minutes:

		if all {
			switch v := interface{}(m.GetMinutes()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ParameterTriggerCronValidationError{
						field:  "Minutes",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ParameterTriggerCronValidationError{
						field:  "Minutes",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMinutes()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ParameterTriggerCronValidationError{
					field:  "Minutes",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ParameterTriggerCron_Hours:

		if all {
			switch v := interface{}(m.GetHours()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ParameterTriggerCronValidationError{
						field:  "Hours",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ParameterTriggerCronValidationError{
						field:  "Hours",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHours()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ParameterTriggerCronValidationError{
					field:  "Hours",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ParameterTriggerCron_Days:

		if all {
			switch v := interface{}(m.GetDays()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ParameterTriggerCronValidationError{
						field:  "Days",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ParameterTriggerCronValidationError{
						field:  "Days",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDays()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ParameterTriggerCronValidationError{
					field:  "Days",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ParameterTriggerCron_Weeks:

		if all {
			switch v := interface{}(m.GetWeeks()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ParameterTriggerCronValidationError{
						field:  "Weeks",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ParameterTriggerCronValidationError{
						field:  "Weeks",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetWeeks()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ParameterTriggerCronValidationError{
					field:  "Weeks",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ParameterTriggerCron_Months:

		if all {
			switch v := interface{}(m.GetMonths()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ParameterTriggerCronValidationError{
						field:  "Months",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ParameterTriggerCronValidationError{
						field:  "Months",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMonths()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ParameterTriggerCronValidationError{
					field:  "Months",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ParameterTriggerCron_NoRepeat:

		if all {
			switch v := interface{}(m.GetNoRepeat()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ParameterTriggerCronValidationError{
						field:  "NoRepeat",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ParameterTriggerCronValidationError{
						field:  "NoRepeat",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetNoRepeat()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ParameterTriggerCronValidationError{
					field:  "NoRepeat",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ParameterTriggerCronMultiError(errors)
	}

	return nil
}

// ParameterTriggerCronMultiError is an error wrapping multiple validation
// errors returned by ParameterTriggerCron.ValidateAll() if the designated
// constraints aren't met.
type ParameterTriggerCronMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParameterTriggerCronMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParameterTriggerCronMultiError) AllErrors() []error { return m }

// ParameterTriggerCronValidationError is the validation error returned by
// ParameterTriggerCron.Validate if the designated constraints aren't met.
type ParameterTriggerCronValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParameterTriggerCronValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParameterTriggerCronValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParameterTriggerCronValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParameterTriggerCronValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParameterTriggerCronValidationError) ErrorName() string {
	return "ParameterTriggerCronValidationError"
}

// Error satisfies the builtin error interface
func (e ParameterTriggerCronValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParameterTriggerCron.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParameterTriggerCronValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParameterTriggerCronValidationError{}

// Validate checks the field values on ParameterTriggerCronMinutes with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ParameterTriggerCronMinutes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParameterTriggerCronMinutes with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ParameterTriggerCronMinutesMultiError, or nil if none found.
func (m *ParameterTriggerCronMinutes) ValidateAll() error {
	return m.validate(true)
}

func (m *ParameterTriggerCronMinutes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ParameterTriggerCronMinutesMultiError(errors)
	}

	return nil
}

// ParameterTriggerCronMinutesMultiError is an error wrapping multiple
// validation errors returned by ParameterTriggerCronMinutes.ValidateAll() if
// the designated constraints aren't met.
type ParameterTriggerCronMinutesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParameterTriggerCronMinutesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParameterTriggerCronMinutesMultiError) AllErrors() []error { return m }

// ParameterTriggerCronMinutesValidationError is the validation error returned
// by ParameterTriggerCronMinutes.Validate if the designated constraints
// aren't met.
type ParameterTriggerCronMinutesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParameterTriggerCronMinutesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParameterTriggerCronMinutesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParameterTriggerCronMinutesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParameterTriggerCronMinutesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParameterTriggerCronMinutesValidationError) ErrorName() string {
	return "ParameterTriggerCronMinutesValidationError"
}

// Error satisfies the builtin error interface
func (e ParameterTriggerCronMinutesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParameterTriggerCronMinutes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParameterTriggerCronMinutesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParameterTriggerCronMinutesValidationError{}

// Validate checks the field values on ParameterTriggerCronHours with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ParameterTriggerCronHours) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParameterTriggerCronHours with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ParameterTriggerCronHoursMultiError, or nil if none found.
func (m *ParameterTriggerCronHours) ValidateAll() error {
	return m.validate(true)
}

func (m *ParameterTriggerCronHours) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetMinute(); val < 0 || val > 59 {
		err := ParameterTriggerCronHoursValidationError{
			field:  "Minute",
			reason: "value must be inside range [0, 59]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ParameterTriggerCronHoursMultiError(errors)
	}

	return nil
}

// ParameterTriggerCronHoursMultiError is an error wrapping multiple validation
// errors returned by ParameterTriggerCronHours.ValidateAll() if the
// designated constraints aren't met.
type ParameterTriggerCronHoursMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParameterTriggerCronHoursMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParameterTriggerCronHoursMultiError) AllErrors() []error { return m }

// ParameterTriggerCronHoursValidationError is the validation error returned by
// ParameterTriggerCronHours.Validate if the designated constraints aren't met.
type ParameterTriggerCronHoursValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParameterTriggerCronHoursValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParameterTriggerCronHoursValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParameterTriggerCronHoursValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParameterTriggerCronHoursValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParameterTriggerCronHoursValidationError) ErrorName() string {
	return "ParameterTriggerCronHoursValidationError"
}

// Error satisfies the builtin error interface
func (e ParameterTriggerCronHoursValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParameterTriggerCronHours.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParameterTriggerCronHoursValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParameterTriggerCronHoursValidationError{}

// Validate checks the field values on ParameterTriggerCronDays with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ParameterTriggerCronDays) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParameterTriggerCronDays with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ParameterTriggerCronDaysMultiError, or nil if none found.
func (m *ParameterTriggerCronDays) ValidateAll() error {
	return m.validate(true)
}

func (m *ParameterTriggerCronDays) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetHour(); val < 0 || val > 23 {
		err := ParameterTriggerCronDaysValidationError{
			field:  "Hour",
			reason: "value must be inside range [0, 23]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetMinute(); val < 0 || val > 59 {
		err := ParameterTriggerCronDaysValidationError{
			field:  "Minute",
			reason: "value must be inside range [0, 59]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ParameterTriggerCronDaysMultiError(errors)
	}

	return nil
}

// ParameterTriggerCronDaysMultiError is an error wrapping multiple validation
// errors returned by ParameterTriggerCronDays.ValidateAll() if the designated
// constraints aren't met.
type ParameterTriggerCronDaysMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParameterTriggerCronDaysMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParameterTriggerCronDaysMultiError) AllErrors() []error { return m }

// ParameterTriggerCronDaysValidationError is the validation error returned by
// ParameterTriggerCronDays.Validate if the designated constraints aren't met.
type ParameterTriggerCronDaysValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParameterTriggerCronDaysValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParameterTriggerCronDaysValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParameterTriggerCronDaysValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParameterTriggerCronDaysValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParameterTriggerCronDaysValidationError) ErrorName() string {
	return "ParameterTriggerCronDaysValidationError"
}

// Error satisfies the builtin error interface
func (e ParameterTriggerCronDaysValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParameterTriggerCronDays.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParameterTriggerCronDaysValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParameterTriggerCronDaysValidationError{}

// Validate checks the field values on ParameterTriggerCronWeeks with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ParameterTriggerCronWeeks) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParameterTriggerCronWeeks with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ParameterTriggerCronWeeksMultiError, or nil if none found.
func (m *ParameterTriggerCronWeeks) ValidateAll() error {
	return m.validate(true)
}

func (m *ParameterTriggerCronWeeks) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetWeekday() {
		_, _ = idx, item

		if val := item; val < 0 || val > 6 {
			err := ParameterTriggerCronWeeksValidationError{
				field:  fmt.Sprintf("Weekday[%v]", idx),
				reason: "value must be inside range [0, 6]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if val := m.GetHour(); val < 0 || val > 23 {
		err := ParameterTriggerCronWeeksValidationError{
			field:  "Hour",
			reason: "value must be inside range [0, 23]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetMinute(); val < 0 || val > 59 {
		err := ParameterTriggerCronWeeksValidationError{
			field:  "Minute",
			reason: "value must be inside range [0, 59]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ParameterTriggerCronWeeksMultiError(errors)
	}

	return nil
}

// ParameterTriggerCronWeeksMultiError is an error wrapping multiple validation
// errors returned by ParameterTriggerCronWeeks.ValidateAll() if the
// designated constraints aren't met.
type ParameterTriggerCronWeeksMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParameterTriggerCronWeeksMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParameterTriggerCronWeeksMultiError) AllErrors() []error { return m }

// ParameterTriggerCronWeeksValidationError is the validation error returned by
// ParameterTriggerCronWeeks.Validate if the designated constraints aren't met.
type ParameterTriggerCronWeeksValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParameterTriggerCronWeeksValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParameterTriggerCronWeeksValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParameterTriggerCronWeeksValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParameterTriggerCronWeeksValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParameterTriggerCronWeeksValidationError) ErrorName() string {
	return "ParameterTriggerCronWeeksValidationError"
}

// Error satisfies the builtin error interface
func (e ParameterTriggerCronWeeksValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParameterTriggerCronWeeks.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParameterTriggerCronWeeksValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParameterTriggerCronWeeksValidationError{}

// Validate checks the field values on ParameterTriggerCronMonths with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ParameterTriggerCronMonths) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParameterTriggerCronMonths with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ParameterTriggerCronMonthsMultiError, or nil if none found.
func (m *ParameterTriggerCronMonths) ValidateAll() error {
	return m.validate(true)
}

func (m *ParameterTriggerCronMonths) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetDayOfMonth() {
		_, _ = idx, item

		if val := item; val < -1 || val > 31 {
			err := ParameterTriggerCronMonthsValidationError{
				field:  fmt.Sprintf("DayOfMonth[%v]", idx),
				reason: "value must be inside range [-1, 31]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if val := m.GetHour(); val < 0 || val > 23 {
		err := ParameterTriggerCronMonthsValidationError{
			field:  "Hour",
			reason: "value must be inside range [0, 23]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetMinute(); val < 0 || val > 59 {
		err := ParameterTriggerCronMonthsValidationError{
			field:  "Minute",
			reason: "value must be inside range [0, 59]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ParameterTriggerCronMonthsMultiError(errors)
	}

	return nil
}

// ParameterTriggerCronMonthsMultiError is an error wrapping multiple
// validation errors returned by ParameterTriggerCronMonths.ValidateAll() if
// the designated constraints aren't met.
type ParameterTriggerCronMonthsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParameterTriggerCronMonthsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParameterTriggerCronMonthsMultiError) AllErrors() []error { return m }

// ParameterTriggerCronMonthsValidationError is the validation error returned
// by ParameterTriggerCronMonths.Validate if the designated constraints aren't met.
type ParameterTriggerCronMonthsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParameterTriggerCronMonthsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParameterTriggerCronMonthsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParameterTriggerCronMonthsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParameterTriggerCronMonthsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParameterTriggerCronMonthsValidationError) ErrorName() string {
	return "ParameterTriggerCronMonthsValidationError"
}

// Error satisfies the builtin error interface
func (e ParameterTriggerCronMonthsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParameterTriggerCronMonths.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParameterTriggerCronMonthsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParameterTriggerCronMonthsValidationError{}

// Validate checks the field values on ParameterTriggerCronNoRepeat with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ParameterTriggerCronNoRepeat) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParameterTriggerCronNoRepeat with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ParameterTriggerCronNoRepeatMultiError, or nil if none found.
func (m *ParameterTriggerCronNoRepeat) ValidateAll() error {
	return m.validate(true)
}

func (m *ParameterTriggerCronNoRepeat) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetYear() < 2022 {
		err := ParameterTriggerCronNoRepeatValidationError{
			field:  "Year",
			reason: "value must be greater than or equal to 2022",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetMonth(); val < 1 || val > 12 {
		err := ParameterTriggerCronNoRepeatValidationError{
			field:  "Month",
			reason: "value must be inside range [1, 12]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetDay(); val < 1 || val > 31 {
		err := ParameterTriggerCronNoRepeatValidationError{
			field:  "Day",
			reason: "value must be inside range [1, 31]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetHour(); val < 0 || val > 23 {
		err := ParameterTriggerCronNoRepeatValidationError{
			field:  "Hour",
			reason: "value must be inside range [0, 23]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetMinute(); val < 0 || val > 59 {
		err := ParameterTriggerCronNoRepeatValidationError{
			field:  "Minute",
			reason: "value must be inside range [0, 59]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ParameterTriggerCronNoRepeatMultiError(errors)
	}

	return nil
}

// ParameterTriggerCronNoRepeatMultiError is an error wrapping multiple
// validation errors returned by ParameterTriggerCronNoRepeat.ValidateAll() if
// the designated constraints aren't met.
type ParameterTriggerCronNoRepeatMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParameterTriggerCronNoRepeatMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParameterTriggerCronNoRepeatMultiError) AllErrors() []error { return m }

// ParameterTriggerCronNoRepeatValidationError is the validation error returned
// by ParameterTriggerCronNoRepeat.Validate if the designated constraints
// aren't met.
type ParameterTriggerCronNoRepeatValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParameterTriggerCronNoRepeatValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParameterTriggerCronNoRepeatValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParameterTriggerCronNoRepeatValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParameterTriggerCronNoRepeatValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParameterTriggerCronNoRepeatValidationError) ErrorName() string {
	return "ParameterTriggerCronNoRepeatValidationError"
}

// Error satisfies the builtin error interface
func (e ParameterTriggerCronNoRepeatValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParameterTriggerCronNoRepeat.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParameterTriggerCronNoRepeatValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParameterTriggerCronNoRepeatValidationError{}

// Validate checks the field values on ParameterTriggerDataEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ParameterTriggerDataEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParameterTriggerDataEvent with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ParameterTriggerDataEventMultiError, or nil if none found.
func (m *ParameterTriggerDataEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *ParameterTriggerDataEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AppId

	// no validation rules for TableId

	// no validation rules for Type

	for idx, item := range m.GetUpdatedColumnIds() {
		_, _ = idx, item

		if utf8.RuneCountInString(item) > 20 {
			err := ParameterTriggerDataEventValidationError{
				field:  fmt.Sprintf("UpdatedColumnIds[%v]", idx),
				reason: "value length must be at most 20 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if all {
		switch v := interface{}(m.GetFilterCondition()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ParameterTriggerDataEventValidationError{
					field:  "FilterCondition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ParameterTriggerDataEventValidationError{
					field:  "FilterCondition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFilterCondition()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ParameterTriggerDataEventValidationError{
				field:  "FilterCondition",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ParameterTriggerDataEventMultiError(errors)
	}

	return nil
}

// ParameterTriggerDataEventMultiError is an error wrapping multiple validation
// errors returned by ParameterTriggerDataEvent.ValidateAll() if the
// designated constraints aren't met.
type ParameterTriggerDataEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParameterTriggerDataEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParameterTriggerDataEventMultiError) AllErrors() []error { return m }

// ParameterTriggerDataEventValidationError is the validation error returned by
// ParameterTriggerDataEvent.Validate if the designated constraints aren't met.
type ParameterTriggerDataEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParameterTriggerDataEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParameterTriggerDataEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParameterTriggerDataEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParameterTriggerDataEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParameterTriggerDataEventValidationError) ErrorName() string {
	return "ParameterTriggerDataEventValidationError"
}

// Error satisfies the builtin error interface
func (e ParameterTriggerDataEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParameterTriggerDataEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParameterTriggerDataEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParameterTriggerDataEventValidationError{}

// Validate checks the field values on ParameterTriggerDateColumnCron with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ParameterTriggerDateColumnCron) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParameterTriggerDateColumnCron with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ParameterTriggerDateColumnCronMultiError, or nil if none found.
func (m *ParameterTriggerDateColumnCron) ValidateAll() error {
	return m.validate(true)
}

func (m *ParameterTriggerDateColumnCron) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AppId

	// no validation rules for TableId

	// no validation rules for ColumnId

	// no validation rules for StartType

	// no validation rules for DeltaTime

	// no validation rules for DeltaTimeUnit

	if all {
		switch v := interface{}(m.GetFilterCondition()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ParameterTriggerDateColumnCronValidationError{
					field:  "FilterCondition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ParameterTriggerDateColumnCronValidationError{
					field:  "FilterCondition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFilterCondition()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ParameterTriggerDateColumnCronValidationError{
				field:  "FilterCondition",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ParameterTriggerDateColumnCronMultiError(errors)
	}

	return nil
}

// ParameterTriggerDateColumnCronMultiError is an error wrapping multiple
// validation errors returned by ParameterTriggerDateColumnCron.ValidateAll()
// if the designated constraints aren't met.
type ParameterTriggerDateColumnCronMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParameterTriggerDateColumnCronMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParameterTriggerDateColumnCronMultiError) AllErrors() []error { return m }

// ParameterTriggerDateColumnCronValidationError is the validation error
// returned by ParameterTriggerDateColumnCron.Validate if the designated
// constraints aren't met.
type ParameterTriggerDateColumnCronValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParameterTriggerDateColumnCronValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParameterTriggerDateColumnCronValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParameterTriggerDateColumnCronValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParameterTriggerDateColumnCronValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParameterTriggerDateColumnCronValidationError) ErrorName() string {
	return "ParameterTriggerDateColumnCronValidationError"
}

// Error satisfies the builtin error interface
func (e ParameterTriggerDateColumnCronValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParameterTriggerDateColumnCron.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParameterTriggerDateColumnCronValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParameterTriggerDateColumnCronValidationError{}

// Validate checks the field values on ParameterTriggerOrgEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ParameterTriggerOrgEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParameterTriggerOrgEvent with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ParameterTriggerOrgEventMultiError, or nil if none found.
func (m *ParameterTriggerOrgEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *ParameterTriggerOrgEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	if len(errors) > 0 {
		return ParameterTriggerOrgEventMultiError(errors)
	}

	return nil
}

// ParameterTriggerOrgEventMultiError is an error wrapping multiple validation
// errors returned by ParameterTriggerOrgEvent.ValidateAll() if the designated
// constraints aren't met.
type ParameterTriggerOrgEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParameterTriggerOrgEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParameterTriggerOrgEventMultiError) AllErrors() []error { return m }

// ParameterTriggerOrgEventValidationError is the validation error returned by
// ParameterTriggerOrgEvent.Validate if the designated constraints aren't met.
type ParameterTriggerOrgEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParameterTriggerOrgEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParameterTriggerOrgEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParameterTriggerOrgEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParameterTriggerOrgEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParameterTriggerOrgEventValidationError) ErrorName() string {
	return "ParameterTriggerOrgEventValidationError"
}

// Error satisfies the builtin error interface
func (e ParameterTriggerOrgEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParameterTriggerOrgEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParameterTriggerOrgEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParameterTriggerOrgEventValidationError{}

// Validate checks the field values on ParameterTriggerUserEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ParameterTriggerUserEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParameterTriggerUserEvent with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ParameterTriggerUserEventMultiError, or nil if none found.
func (m *ParameterTriggerUserEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *ParameterTriggerUserEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	if len(errors) > 0 {
		return ParameterTriggerUserEventMultiError(errors)
	}

	return nil
}

// ParameterTriggerUserEventMultiError is an error wrapping multiple validation
// errors returned by ParameterTriggerUserEvent.ValidateAll() if the
// designated constraints aren't met.
type ParameterTriggerUserEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParameterTriggerUserEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParameterTriggerUserEventMultiError) AllErrors() []error { return m }

// ParameterTriggerUserEventValidationError is the validation error returned by
// ParameterTriggerUserEvent.Validate if the designated constraints aren't met.
type ParameterTriggerUserEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParameterTriggerUserEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParameterTriggerUserEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParameterTriggerUserEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParameterTriggerUserEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParameterTriggerUserEventValidationError) ErrorName() string {
	return "ParameterTriggerUserEventValidationError"
}

// Error satisfies the builtin error interface
func (e ParameterTriggerUserEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParameterTriggerUserEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParameterTriggerUserEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParameterTriggerUserEventValidationError{}

// Validate checks the field values on ParameterTriggerWebhook with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ParameterTriggerWebhook) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParameterTriggerWebhook with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ParameterTriggerWebhookMultiError, or nil if none found.
func (m *ParameterTriggerWebhook) ValidateAll() error {
	return m.validate(true)
}

func (m *ParameterTriggerWebhook) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetPath()) != 36 {
		err := ParameterTriggerWebhookValidationError{
			field:  "Path",
			reason: "value length must be 36 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if len(errors) > 0 {
		return ParameterTriggerWebhookMultiError(errors)
	}

	return nil
}

// ParameterTriggerWebhookMultiError is an error wrapping multiple validation
// errors returned by ParameterTriggerWebhook.ValidateAll() if the designated
// constraints aren't met.
type ParameterTriggerWebhookMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParameterTriggerWebhookMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParameterTriggerWebhookMultiError) AllErrors() []error { return m }

// ParameterTriggerWebhookValidationError is the validation error returned by
// ParameterTriggerWebhook.Validate if the designated constraints aren't met.
type ParameterTriggerWebhookValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParameterTriggerWebhookValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParameterTriggerWebhookValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParameterTriggerWebhookValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParameterTriggerWebhookValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParameterTriggerWebhookValidationError) ErrorName() string {
	return "ParameterTriggerWebhookValidationError"
}

// Error satisfies the builtin error interface
func (e ParameterTriggerWebhookValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParameterTriggerWebhook.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParameterTriggerWebhookValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParameterTriggerWebhookValidationError{}

// Validate checks the field values on ParameterActionMysql with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ParameterActionMysql) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParameterActionMysql with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ParameterActionMysqlMultiError, or nil if none found.
func (m *ParameterActionMysql) ValidateAll() error {
	return m.validate(true)
}

func (m *ParameterActionMysql) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetIntegrationId()); l < 0 || l > 20 {
		err := ParameterActionMysqlValidationError{
			field:  "IntegrationId",
			reason: "value length must be between 0 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Operation

	if all {
		switch v := interface{}(m.GetSql()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ParameterActionMysqlValidationError{
					field:  "Sql",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ParameterActionMysqlValidationError{
					field:  "Sql",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSql()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ParameterActionMysqlValidationError{
				field:  "Sql",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ParameterActionMysqlMultiError(errors)
	}

	return nil
}

// ParameterActionMysqlMultiError is an error wrapping multiple validation
// errors returned by ParameterActionMysql.ValidateAll() if the designated
// constraints aren't met.
type ParameterActionMysqlMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParameterActionMysqlMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParameterActionMysqlMultiError) AllErrors() []error { return m }

// ParameterActionMysqlValidationError is the validation error returned by
// ParameterActionMysql.Validate if the designated constraints aren't met.
type ParameterActionMysqlValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParameterActionMysqlValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParameterActionMysqlValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParameterActionMysqlValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParameterActionMysqlValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParameterActionMysqlValidationError) ErrorName() string {
	return "ParameterActionMysqlValidationError"
}

// Error satisfies the builtin error interface
func (e ParameterActionMysqlValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParameterActionMysql.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParameterActionMysqlValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParameterActionMysqlValidationError{}

// Validate checks the field values on ParameterActionPostgres with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ParameterActionPostgres) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParameterActionPostgres with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ParameterActionPostgresMultiError, or nil if none found.
func (m *ParameterActionPostgres) ValidateAll() error {
	return m.validate(true)
}

func (m *ParameterActionPostgres) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetIntegrationId()); l < 0 || l > 20 {
		err := ParameterActionPostgresValidationError{
			field:  "IntegrationId",
			reason: "value length must be between 0 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Operation

	if all {
		switch v := interface{}(m.GetSql()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ParameterActionPostgresValidationError{
					field:  "Sql",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ParameterActionPostgresValidationError{
					field:  "Sql",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSql()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ParameterActionPostgresValidationError{
				field:  "Sql",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ParameterActionPostgresMultiError(errors)
	}

	return nil
}

// ParameterActionPostgresMultiError is an error wrapping multiple validation
// errors returned by ParameterActionPostgres.ValidateAll() if the designated
// constraints aren't met.
type ParameterActionPostgresMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParameterActionPostgresMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParameterActionPostgresMultiError) AllErrors() []error { return m }

// ParameterActionPostgresValidationError is the validation error returned by
// ParameterActionPostgres.Validate if the designated constraints aren't met.
type ParameterActionPostgresValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParameterActionPostgresValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParameterActionPostgresValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParameterActionPostgresValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParameterActionPostgresValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParameterActionPostgresValidationError) ErrorName() string {
	return "ParameterActionPostgresValidationError"
}

// Error satisfies the builtin error interface
func (e ParameterActionPostgresValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParameterActionPostgres.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParameterActionPostgresValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParameterActionPostgresValidationError{}

// Validate checks the field values on ParameterActionSendEmail with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ParameterActionSendEmail) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParameterActionSendEmail with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ParameterActionSendEmailMultiError, or nil if none found.
func (m *ParameterActionSendEmail) ValidateAll() error {
	return m.validate(true)
}

func (m *ParameterActionSendEmail) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IntegrationId

	if all {
		switch v := interface{}(m.GetFromName()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ParameterActionSendEmailValidationError{
					field:  "FromName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ParameterActionSendEmailValidationError{
					field:  "FromName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFromName()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ParameterActionSendEmailValidationError{
				field:  "FromName",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFromEmail()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ParameterActionSendEmailValidationError{
					field:  "FromEmail",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ParameterActionSendEmailValidationError{
					field:  "FromEmail",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFromEmail()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ParameterActionSendEmailValidationError{
				field:  "FromEmail",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetToEmail()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ParameterActionSendEmailValidationError{
					field:  "ToEmail",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ParameterActionSendEmailValidationError{
					field:  "ToEmail",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetToEmail()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ParameterActionSendEmailValidationError{
				field:  "ToEmail",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCcEmail()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ParameterActionSendEmailValidationError{
					field:  "CcEmail",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ParameterActionSendEmailValidationError{
					field:  "CcEmail",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCcEmail()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ParameterActionSendEmailValidationError{
				field:  "CcEmail",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetReplyToEmail()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ParameterActionSendEmailValidationError{
					field:  "ReplyToEmail",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ParameterActionSendEmailValidationError{
					field:  "ReplyToEmail",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReplyToEmail()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ParameterActionSendEmailValidationError{
				field:  "ReplyToEmail",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSubject()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ParameterActionSendEmailValidationError{
					field:  "Subject",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ParameterActionSendEmailValidationError{
					field:  "Subject",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubject()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ParameterActionSendEmailValidationError{
				field:  "Subject",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for EmailFormat

	if all {
		switch v := interface{}(m.GetContent()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ParameterActionSendEmailValidationError{
					field:  "Content",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ParameterActionSendEmailValidationError{
					field:  "Content",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetContent()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ParameterActionSendEmailValidationError{
				field:  "Content",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ParameterActionSendEmailMultiError(errors)
	}

	return nil
}

// ParameterActionSendEmailMultiError is an error wrapping multiple validation
// errors returned by ParameterActionSendEmail.ValidateAll() if the designated
// constraints aren't met.
type ParameterActionSendEmailMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParameterActionSendEmailMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParameterActionSendEmailMultiError) AllErrors() []error { return m }

// ParameterActionSendEmailValidationError is the validation error returned by
// ParameterActionSendEmail.Validate if the designated constraints aren't met.
type ParameterActionSendEmailValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParameterActionSendEmailValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParameterActionSendEmailValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParameterActionSendEmailValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParameterActionSendEmailValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParameterActionSendEmailValidationError) ErrorName() string {
	return "ParameterActionSendEmailValidationError"
}

// Error satisfies the builtin error interface
func (e ParameterActionSendEmailValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParameterActionSendEmail.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParameterActionSendEmailValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParameterActionSendEmailValidationError{}

// Validate checks the field values on ParameterActionSendCardFeishu with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ParameterActionSendCardFeishu) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParameterActionSendCardFeishu with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ParameterActionSendCardFeishuMultiError, or nil if none found.
func (m *ParameterActionSendCardFeishu) ValidateAll() error {
	return m.validate(true)
}

func (m *ParameterActionSendCardFeishu) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetIds()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ParameterActionSendCardFeishuValidationError{
					field:  "Ids",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ParameterActionSendCardFeishuValidationError{
					field:  "Ids",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIds()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ParameterActionSendCardFeishuValidationError{
				field:  "Ids",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTitle()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ParameterActionSendCardFeishuValidationError{
					field:  "Title",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ParameterActionSendCardFeishuValidationError{
					field:  "Title",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTitle()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ParameterActionSendCardFeishuValidationError{
				field:  "Title",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetContent()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ParameterActionSendCardFeishuValidationError{
					field:  "Content",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ParameterActionSendCardFeishuValidationError{
					field:  "Content",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetContent()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ParameterActionSendCardFeishuValidationError{
				field:  "Content",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ParameterActionSendCardFeishuMultiError(errors)
	}

	return nil
}

// ParameterActionSendCardFeishuMultiError is an error wrapping multiple
// validation errors returned by ParameterActionSendCardFeishu.ValidateAll()
// if the designated constraints aren't met.
type ParameterActionSendCardFeishuMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParameterActionSendCardFeishuMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParameterActionSendCardFeishuMultiError) AllErrors() []error { return m }

// ParameterActionSendCardFeishuValidationError is the validation error
// returned by ParameterActionSendCardFeishu.Validate if the designated
// constraints aren't met.
type ParameterActionSendCardFeishuValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParameterActionSendCardFeishuValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParameterActionSendCardFeishuValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParameterActionSendCardFeishuValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParameterActionSendCardFeishuValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParameterActionSendCardFeishuValidationError) ErrorName() string {
	return "ParameterActionSendCardFeishuValidationError"
}

// Error satisfies the builtin error interface
func (e ParameterActionSendCardFeishuValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParameterActionSendCardFeishu.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParameterActionSendCardFeishuValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParameterActionSendCardFeishuValidationError{}

// Validate checks the field values on ParameterActionSendCardDingTalk with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ParameterActionSendCardDingTalk) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParameterActionSendCardDingTalk with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ParameterActionSendCardDingTalkMultiError, or nil if none found.
func (m *ParameterActionSendCardDingTalk) ValidateAll() error {
	return m.validate(true)
}

func (m *ParameterActionSendCardDingTalk) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetIds()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ParameterActionSendCardDingTalkValidationError{
					field:  "Ids",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ParameterActionSendCardDingTalkValidationError{
					field:  "Ids",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIds()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ParameterActionSendCardDingTalkValidationError{
				field:  "Ids",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTitle()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ParameterActionSendCardDingTalkValidationError{
					field:  "Title",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ParameterActionSendCardDingTalkValidationError{
					field:  "Title",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTitle()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ParameterActionSendCardDingTalkValidationError{
				field:  "Title",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetContent()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ParameterActionSendCardDingTalkValidationError{
					field:  "Content",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ParameterActionSendCardDingTalkValidationError{
					field:  "Content",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetContent()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ParameterActionSendCardDingTalkValidationError{
				field:  "Content",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ParameterActionSendCardDingTalkMultiError(errors)
	}

	return nil
}

// ParameterActionSendCardDingTalkMultiError is an error wrapping multiple
// validation errors returned by ParameterActionSendCardDingTalk.ValidateAll()
// if the designated constraints aren't met.
type ParameterActionSendCardDingTalkMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParameterActionSendCardDingTalkMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParameterActionSendCardDingTalkMultiError) AllErrors() []error { return m }

// ParameterActionSendCardDingTalkValidationError is the validation error
// returned by ParameterActionSendCardDingTalk.Validate if the designated
// constraints aren't met.
type ParameterActionSendCardDingTalkValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParameterActionSendCardDingTalkValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParameterActionSendCardDingTalkValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParameterActionSendCardDingTalkValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParameterActionSendCardDingTalkValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParameterActionSendCardDingTalkValidationError) ErrorName() string {
	return "ParameterActionSendCardDingTalkValidationError"
}

// Error satisfies the builtin error interface
func (e ParameterActionSendCardDingTalkValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParameterActionSendCardDingTalk.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParameterActionSendCardDingTalkValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParameterActionSendCardDingTalkValidationError{}

// Validate checks the field values on ParameterActionSendCardWeCom with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ParameterActionSendCardWeCom) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParameterActionSendCardWeCom with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ParameterActionSendCardWeComMultiError, or nil if none found.
func (m *ParameterActionSendCardWeCom) ValidateAll() error {
	return m.validate(true)
}

func (m *ParameterActionSendCardWeCom) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetIds()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ParameterActionSendCardWeComValidationError{
					field:  "Ids",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ParameterActionSendCardWeComValidationError{
					field:  "Ids",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIds()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ParameterActionSendCardWeComValidationError{
				field:  "Ids",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTitle()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ParameterActionSendCardWeComValidationError{
					field:  "Title",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ParameterActionSendCardWeComValidationError{
					field:  "Title",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTitle()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ParameterActionSendCardWeComValidationError{
				field:  "Title",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetContent()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ParameterActionSendCardWeComValidationError{
					field:  "Content",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ParameterActionSendCardWeComValidationError{
					field:  "Content",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetContent()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ParameterActionSendCardWeComValidationError{
				field:  "Content",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ParameterActionSendCardWeComMultiError(errors)
	}

	return nil
}

// ParameterActionSendCardWeComMultiError is an error wrapping multiple
// validation errors returned by ParameterActionSendCardWeCom.ValidateAll() if
// the designated constraints aren't met.
type ParameterActionSendCardWeComMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParameterActionSendCardWeComMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParameterActionSendCardWeComMultiError) AllErrors() []error { return m }

// ParameterActionSendCardWeComValidationError is the validation error returned
// by ParameterActionSendCardWeCom.Validate if the designated constraints
// aren't met.
type ParameterActionSendCardWeComValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParameterActionSendCardWeComValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParameterActionSendCardWeComValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParameterActionSendCardWeComValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParameterActionSendCardWeComValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParameterActionSendCardWeComValidationError) ErrorName() string {
	return "ParameterActionSendCardWeComValidationError"
}

// Error satisfies the builtin error interface
func (e ParameterActionSendCardWeComValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParameterActionSendCardWeCom.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParameterActionSendCardWeComValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParameterActionSendCardWeComValidationError{}
