// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// protoc-gen-go-http v2.1.4

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

type AutomationInnerHTTPServer interface {
	ApplyTemplate(context.Context, *ApplyTemplateReq) (*ApplyTemplateReply, error)
	BatchRebuildActive(context.Context, *BatchRebuildActiveReq) (*BatchRebuildActiveReply, error)
	CreateTodo(context.Context, *CreateTodoReq) (*CreateTodoReply, error)
	GlobalSwitchOff(context.Context, *GlobalSwitchOffReq) (*GlobalSwitchOffReply, error)
	HandleWorkflowError(context.Context, *HandleWorkflowErrorReq) (*HandleWorkflowErrorReply, error)
	HandleWorkflowExecute(context.Context, *HandleWorkflowExecuteReq) (*HandleWorkflowExecuteReply, error)
	UpdateTodo(context.Context, *UpdateTodoReq) (*UpdateTodoReply, error)
}

func RegisterAutomationInnerHTTPServer(s *http.Server, srv AutomationInnerHTTPServer) {
	r := s.Route("/")
	r.POST("/inner/v1/workflows/applyTemplate", _AutomationInner_ApplyTemplate0_HTTP_Handler(srv))
	r.POST("/inner/v1/workflows/handleExecute", _AutomationInner_HandleWorkflowExecute0_HTTP_Handler(srv))
	r.POST("/inner/v1/workflows/handleError", _AutomationInner_HandleWorkflowError0_HTTP_Handler(srv))
	r.GET("/inner/v1/batch/rebuildActive/{orgId}", _AutomationInner_BatchRebuildActive0_HTTP_Handler(srv))
	r.POST("/inner/v1/global/switch/off", _AutomationInner_GlobalSwitchOff0_HTTP_Handler(srv))
	r.POST("/inner/v1/todo", _AutomationInner_CreateTodo0_HTTP_Handler(srv))
	r.PUT("/inner/v1/todo", _AutomationInner_UpdateTodo0_HTTP_Handler(srv))
}

func _AutomationInner_ApplyTemplate0_HTTP_Handler(srv AutomationInnerHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ApplyTemplateReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/automation.v1.AutomationInner/ApplyTemplate")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ApplyTemplate(ctx, req.(*ApplyTemplateReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ApplyTemplateReply)
		return ctx.Result(200, reply)
	}
}

func _AutomationInner_HandleWorkflowExecute0_HTTP_Handler(srv AutomationInnerHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in HandleWorkflowExecuteReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/automation.v1.AutomationInner/HandleWorkflowExecute")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.HandleWorkflowExecute(ctx, req.(*HandleWorkflowExecuteReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*HandleWorkflowExecuteReply)
		return ctx.Result(200, reply)
	}
}

func _AutomationInner_HandleWorkflowError0_HTTP_Handler(srv AutomationInnerHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in HandleWorkflowErrorReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/automation.v1.AutomationInner/HandleWorkflowError")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.HandleWorkflowError(ctx, req.(*HandleWorkflowErrorReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*HandleWorkflowErrorReply)
		return ctx.Result(200, reply)
	}
}

func _AutomationInner_BatchRebuildActive0_HTTP_Handler(srv AutomationInnerHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in BatchRebuildActiveReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/automation.v1.AutomationInner/BatchRebuildActive")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.BatchRebuildActive(ctx, req.(*BatchRebuildActiveReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*BatchRebuildActiveReply)
		return ctx.Result(200, reply)
	}
}

func _AutomationInner_GlobalSwitchOff0_HTTP_Handler(srv AutomationInnerHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GlobalSwitchOffReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/automation.v1.AutomationInner/GlobalSwitchOff")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GlobalSwitchOff(ctx, req.(*GlobalSwitchOffReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GlobalSwitchOffReply)
		return ctx.Result(200, reply)
	}
}

func _AutomationInner_CreateTodo0_HTTP_Handler(srv AutomationInnerHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CreateTodoReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/automation.v1.AutomationInner/CreateTodo")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateTodo(ctx, req.(*CreateTodoReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CreateTodoReply)
		return ctx.Result(200, reply)
	}
}

func _AutomationInner_UpdateTodo0_HTTP_Handler(srv AutomationInnerHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UpdateTodoReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/automation.v1.AutomationInner/UpdateTodo")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateTodo(ctx, req.(*UpdateTodoReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UpdateTodoReply)
		return ctx.Result(200, reply)
	}
}

type AutomationInnerHTTPClient interface {
	ApplyTemplate(ctx context.Context, req *ApplyTemplateReq, opts ...http.CallOption) (rsp *ApplyTemplateReply, err error)
	BatchRebuildActive(ctx context.Context, req *BatchRebuildActiveReq, opts ...http.CallOption) (rsp *BatchRebuildActiveReply, err error)
	CreateTodo(ctx context.Context, req *CreateTodoReq, opts ...http.CallOption) (rsp *CreateTodoReply, err error)
	GlobalSwitchOff(ctx context.Context, req *GlobalSwitchOffReq, opts ...http.CallOption) (rsp *GlobalSwitchOffReply, err error)
	HandleWorkflowError(ctx context.Context, req *HandleWorkflowErrorReq, opts ...http.CallOption) (rsp *HandleWorkflowErrorReply, err error)
	HandleWorkflowExecute(ctx context.Context, req *HandleWorkflowExecuteReq, opts ...http.CallOption) (rsp *HandleWorkflowExecuteReply, err error)
	UpdateTodo(ctx context.Context, req *UpdateTodoReq, opts ...http.CallOption) (rsp *UpdateTodoReply, err error)
}

type AutomationInnerHTTPClientImpl struct {
	cc *http.Client
}

func NewAutomationInnerHTTPClient(client *http.Client) AutomationInnerHTTPClient {
	return &AutomationInnerHTTPClientImpl{client}
}

func (c *AutomationInnerHTTPClientImpl) ApplyTemplate(ctx context.Context, in *ApplyTemplateReq, opts ...http.CallOption) (*ApplyTemplateReply, error) {
	var out ApplyTemplateReply
	pattern := "/inner/v1/workflows/applyTemplate"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation("/automation.v1.AutomationInner/ApplyTemplate"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *AutomationInnerHTTPClientImpl) BatchRebuildActive(ctx context.Context, in *BatchRebuildActiveReq, opts ...http.CallOption) (*BatchRebuildActiveReply, error) {
	var out BatchRebuildActiveReply
	pattern := "/inner/v1/batch/rebuildActive/{orgId}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/automation.v1.AutomationInner/BatchRebuildActive"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *AutomationInnerHTTPClientImpl) CreateTodo(ctx context.Context, in *CreateTodoReq, opts ...http.CallOption) (*CreateTodoReply, error) {
	var out CreateTodoReply
	pattern := "/inner/v1/todo"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation("/automation.v1.AutomationInner/CreateTodo"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *AutomationInnerHTTPClientImpl) GlobalSwitchOff(ctx context.Context, in *GlobalSwitchOffReq, opts ...http.CallOption) (*GlobalSwitchOffReply, error) {
	var out GlobalSwitchOffReply
	pattern := "/inner/v1/global/switch/off"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation("/automation.v1.AutomationInner/GlobalSwitchOff"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *AutomationInnerHTTPClientImpl) HandleWorkflowError(ctx context.Context, in *HandleWorkflowErrorReq, opts ...http.CallOption) (*HandleWorkflowErrorReply, error) {
	var out HandleWorkflowErrorReply
	pattern := "/inner/v1/workflows/handleError"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation("/automation.v1.AutomationInner/HandleWorkflowError"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *AutomationInnerHTTPClientImpl) HandleWorkflowExecute(ctx context.Context, in *HandleWorkflowExecuteReq, opts ...http.CallOption) (*HandleWorkflowExecuteReply, error) {
	var out HandleWorkflowExecuteReply
	pattern := "/inner/v1/workflows/handleExecute"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation("/automation.v1.AutomationInner/HandleWorkflowExecute"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *AutomationInnerHTTPClientImpl) UpdateTodo(ctx context.Context, in *UpdateTodoReq, opts ...http.CallOption) (*UpdateTodoReply, error) {
	var out UpdateTodoReply
	pattern := "/inner/v1/todo"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation("/automation.v1.AutomationInner/UpdateTodo"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PUT", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}
