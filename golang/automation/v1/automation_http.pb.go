// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// protoc-gen-go-http v2.1.4

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

type AutomationHTTPServer interface {
	ActivateWorkflow(context.Context, *ActivateWorkflowReq) (*ActivateWorkflowReply, error)
	CallWebhook(context.Context, *CallWebhookReq) (*CallWebhookReply, error)
	DeactivateWorkflow(context.Context, *DeactivateWorkflowReq) (*DeactivateWorkflowReply, error)
	DeleteIntegration(context.Context, *DeleteIntegrationReq) (*DeleteIntegrationReply, error)
	DeleteWorkflow(context.Context, *DeleteWorkflowReq) (*DeleteWorkflowReply, error)
	GetExecution(context.Context, *GetExecutionReq) (*GetExecutionReply, error)
	GetExecutions(context.Context, *GetExecutionsReq) (*GetExecutionsReply, error)
	GetIntegration(context.Context, *GetIntegrationReq) (*GetIntegrationReply, error)
	GetIntegrations(context.Context, *GetIntegrationsReq) (*GetIntegrationsReply, error)
	GetIntegrationsByType(context.Context, *GetIntegrationsByTypeReq) (*GetIntegrationsByTypeReply, error)
	GetTodo(context.Context, *GetTodoReq) (*GetTodoReply, error)
	GetTodosByExecution(context.Context, *GetTodosByExecutionReq) (*GetTodosByExecutionReply, error)
	GetWorkflow(context.Context, *GetWorkflowReq) (*GetWorkflowReply, error)
	GetWorkflowsByApp(context.Context, *GetWorkflowsByAppReq) (*GetWorkflowsByAppReply, error)
	SaveIntegration(context.Context, *SaveIntegrationReq) (*SaveIntegrationReply, error)
	SaveWorkflow(context.Context, *SaveWorkflowReq) (*SaveWorkflowReply, error)
	SaveWorkflowMeta(context.Context, *SaveWorkflowMetaReq) (*SaveWorkflowMetaReply, error)
	TodoFilter(context.Context, *TodoFilterReq) (*TodoFilterReply, error)
	TodoStat(context.Context, *TodoStatReq) (*TodoStatReply, error)
}

func RegisterAutomationHTTPServer(s *http.Server, srv AutomationHTTPServer) {
	r := s.Route("/")
	r.GET("/v1/workflows", _Automation_GetWorkflowsByApp0_HTTP_Handler(srv))
	r.GET("/v1/workflows/{id}", _Automation_GetWorkflow0_HTTP_Handler(srv))
	r.POST("/v1/workflows/meta", _Automation_SaveWorkflowMeta0_HTTP_Handler(srv))
	r.POST("/v1/workflows", _Automation_SaveWorkflow0_HTTP_Handler(srv))
	r.DELETE("/v1/workflows/{id}", _Automation_DeleteWorkflow0_HTTP_Handler(srv))
	r.POST("/v1/workflows/{id}/activate", _Automation_ActivateWorkflow0_HTTP_Handler(srv))
	r.POST("/v1/workflows/{id}/deactivate", _Automation_DeactivateWorkflow0_HTTP_Handler(srv))
	r.GET("/v1/executions", _Automation_GetExecutions0_HTTP_Handler(srv))
	r.GET("/v1/executions/{id}", _Automation_GetExecution0_HTTP_Handler(srv))
	r.POST("/v1/webhook/{webhookId}", _Automation_CallWebhook0_HTTP_Handler(srv))
	r.POST("/v1/integrations", _Automation_SaveIntegration0_HTTP_Handler(srv))
	r.GET("/v1/integrations", _Automation_GetIntegrations0_HTTP_Handler(srv))
	r.GET("/v1/integrations/filter", _Automation_GetIntegrationsByType0_HTTP_Handler(srv))
	r.GET("/v1/integrations/{id}", _Automation_GetIntegration0_HTTP_Handler(srv))
	r.DELETE("/v1/integrations/{id}", _Automation_DeleteIntegration0_HTTP_Handler(srv))
	r.GET("/v1/todo/byExecution", _Automation_GetTodosByExecution0_HTTP_Handler(srv))
	r.GET("/v1/todo/stat", _Automation_TodoStat0_HTTP_Handler(srv))
	r.GET("/v1/todo/filter", _Automation_TodoFilter0_HTTP_Handler(srv))
	r.GET("/v1/todo/{id}", _Automation_GetTodo0_HTTP_Handler(srv))
}

func _Automation_GetWorkflowsByApp0_HTTP_Handler(srv AutomationHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetWorkflowsByAppReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/automation.v1.Automation/GetWorkflowsByApp")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetWorkflowsByApp(ctx, req.(*GetWorkflowsByAppReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetWorkflowsByAppReply)
		return ctx.Result(200, reply)
	}
}

func _Automation_GetWorkflow0_HTTP_Handler(srv AutomationHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetWorkflowReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/automation.v1.Automation/GetWorkflow")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetWorkflow(ctx, req.(*GetWorkflowReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetWorkflowReply)
		return ctx.Result(200, reply)
	}
}

func _Automation_SaveWorkflowMeta0_HTTP_Handler(srv AutomationHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in SaveWorkflowMetaReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/automation.v1.Automation/SaveWorkflowMeta")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.SaveWorkflowMeta(ctx, req.(*SaveWorkflowMetaReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*SaveWorkflowMetaReply)
		return ctx.Result(200, reply)
	}
}

func _Automation_SaveWorkflow0_HTTP_Handler(srv AutomationHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in SaveWorkflowReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/automation.v1.Automation/SaveWorkflow")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.SaveWorkflow(ctx, req.(*SaveWorkflowReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*SaveWorkflowReply)
		return ctx.Result(200, reply)
	}
}

func _Automation_DeleteWorkflow0_HTTP_Handler(srv AutomationHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DeleteWorkflowReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/automation.v1.Automation/DeleteWorkflow")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteWorkflow(ctx, req.(*DeleteWorkflowReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DeleteWorkflowReply)
		return ctx.Result(200, reply)
	}
}

func _Automation_ActivateWorkflow0_HTTP_Handler(srv AutomationHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ActivateWorkflowReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/automation.v1.Automation/ActivateWorkflow")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ActivateWorkflow(ctx, req.(*ActivateWorkflowReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ActivateWorkflowReply)
		return ctx.Result(200, reply)
	}
}

func _Automation_DeactivateWorkflow0_HTTP_Handler(srv AutomationHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DeactivateWorkflowReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/automation.v1.Automation/DeactivateWorkflow")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeactivateWorkflow(ctx, req.(*DeactivateWorkflowReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DeactivateWorkflowReply)
		return ctx.Result(200, reply)
	}
}

func _Automation_GetExecutions0_HTTP_Handler(srv AutomationHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetExecutionsReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/automation.v1.Automation/GetExecutions")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetExecutions(ctx, req.(*GetExecutionsReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetExecutionsReply)
		return ctx.Result(200, reply)
	}
}

func _Automation_GetExecution0_HTTP_Handler(srv AutomationHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetExecutionReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/automation.v1.Automation/GetExecution")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetExecution(ctx, req.(*GetExecutionReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetExecutionReply)
		return ctx.Result(200, reply)
	}
}

func _Automation_CallWebhook0_HTTP_Handler(srv AutomationHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CallWebhookReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/automation.v1.Automation/CallWebhook")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CallWebhook(ctx, req.(*CallWebhookReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CallWebhookReply)
		return ctx.Result(200, reply)
	}
}

func _Automation_SaveIntegration0_HTTP_Handler(srv AutomationHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in SaveIntegrationReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/automation.v1.Automation/SaveIntegration")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.SaveIntegration(ctx, req.(*SaveIntegrationReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*SaveIntegrationReply)
		return ctx.Result(200, reply)
	}
}

func _Automation_GetIntegrations0_HTTP_Handler(srv AutomationHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetIntegrationsReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/automation.v1.Automation/GetIntegrations")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetIntegrations(ctx, req.(*GetIntegrationsReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetIntegrationsReply)
		return ctx.Result(200, reply)
	}
}

func _Automation_GetIntegrationsByType0_HTTP_Handler(srv AutomationHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetIntegrationsByTypeReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/automation.v1.Automation/GetIntegrationsByType")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetIntegrationsByType(ctx, req.(*GetIntegrationsByTypeReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetIntegrationsByTypeReply)
		return ctx.Result(200, reply)
	}
}

func _Automation_GetIntegration0_HTTP_Handler(srv AutomationHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetIntegrationReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/automation.v1.Automation/GetIntegration")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetIntegration(ctx, req.(*GetIntegrationReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetIntegrationReply)
		return ctx.Result(200, reply)
	}
}

func _Automation_DeleteIntegration0_HTTP_Handler(srv AutomationHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DeleteIntegrationReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/automation.v1.Automation/DeleteIntegration")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteIntegration(ctx, req.(*DeleteIntegrationReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DeleteIntegrationReply)
		return ctx.Result(200, reply)
	}
}

func _Automation_GetTodosByExecution0_HTTP_Handler(srv AutomationHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetTodosByExecutionReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/automation.v1.Automation/GetTodosByExecution")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetTodosByExecution(ctx, req.(*GetTodosByExecutionReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetTodosByExecutionReply)
		return ctx.Result(200, reply)
	}
}

func _Automation_TodoStat0_HTTP_Handler(srv AutomationHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in TodoStatReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/automation.v1.Automation/TodoStat")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.TodoStat(ctx, req.(*TodoStatReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*TodoStatReply)
		return ctx.Result(200, reply)
	}
}

func _Automation_TodoFilter0_HTTP_Handler(srv AutomationHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in TodoFilterReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/automation.v1.Automation/TodoFilter")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.TodoFilter(ctx, req.(*TodoFilterReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*TodoFilterReply)
		return ctx.Result(200, reply)
	}
}

func _Automation_GetTodo0_HTTP_Handler(srv AutomationHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetTodoReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/automation.v1.Automation/GetTodo")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetTodo(ctx, req.(*GetTodoReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetTodoReply)
		return ctx.Result(200, reply)
	}
}

type AutomationHTTPClient interface {
	ActivateWorkflow(ctx context.Context, req *ActivateWorkflowReq, opts ...http.CallOption) (rsp *ActivateWorkflowReply, err error)
	CallWebhook(ctx context.Context, req *CallWebhookReq, opts ...http.CallOption) (rsp *CallWebhookReply, err error)
	DeactivateWorkflow(ctx context.Context, req *DeactivateWorkflowReq, opts ...http.CallOption) (rsp *DeactivateWorkflowReply, err error)
	DeleteIntegration(ctx context.Context, req *DeleteIntegrationReq, opts ...http.CallOption) (rsp *DeleteIntegrationReply, err error)
	DeleteWorkflow(ctx context.Context, req *DeleteWorkflowReq, opts ...http.CallOption) (rsp *DeleteWorkflowReply, err error)
	GetExecution(ctx context.Context, req *GetExecutionReq, opts ...http.CallOption) (rsp *GetExecutionReply, err error)
	GetExecutions(ctx context.Context, req *GetExecutionsReq, opts ...http.CallOption) (rsp *GetExecutionsReply, err error)
	GetIntegration(ctx context.Context, req *GetIntegrationReq, opts ...http.CallOption) (rsp *GetIntegrationReply, err error)
	GetIntegrations(ctx context.Context, req *GetIntegrationsReq, opts ...http.CallOption) (rsp *GetIntegrationsReply, err error)
	GetIntegrationsByType(ctx context.Context, req *GetIntegrationsByTypeReq, opts ...http.CallOption) (rsp *GetIntegrationsByTypeReply, err error)
	GetTodo(ctx context.Context, req *GetTodoReq, opts ...http.CallOption) (rsp *GetTodoReply, err error)
	GetTodosByExecution(ctx context.Context, req *GetTodosByExecutionReq, opts ...http.CallOption) (rsp *GetTodosByExecutionReply, err error)
	GetWorkflow(ctx context.Context, req *GetWorkflowReq, opts ...http.CallOption) (rsp *GetWorkflowReply, err error)
	GetWorkflowsByApp(ctx context.Context, req *GetWorkflowsByAppReq, opts ...http.CallOption) (rsp *GetWorkflowsByAppReply, err error)
	SaveIntegration(ctx context.Context, req *SaveIntegrationReq, opts ...http.CallOption) (rsp *SaveIntegrationReply, err error)
	SaveWorkflow(ctx context.Context, req *SaveWorkflowReq, opts ...http.CallOption) (rsp *SaveWorkflowReply, err error)
	SaveWorkflowMeta(ctx context.Context, req *SaveWorkflowMetaReq, opts ...http.CallOption) (rsp *SaveWorkflowMetaReply, err error)
	TodoFilter(ctx context.Context, req *TodoFilterReq, opts ...http.CallOption) (rsp *TodoFilterReply, err error)
	TodoStat(ctx context.Context, req *TodoStatReq, opts ...http.CallOption) (rsp *TodoStatReply, err error)
}

type AutomationHTTPClientImpl struct {
	cc *http.Client
}

func NewAutomationHTTPClient(client *http.Client) AutomationHTTPClient {
	return &AutomationHTTPClientImpl{client}
}

func (c *AutomationHTTPClientImpl) ActivateWorkflow(ctx context.Context, in *ActivateWorkflowReq, opts ...http.CallOption) (*ActivateWorkflowReply, error) {
	var out ActivateWorkflowReply
	pattern := "/v1/workflows/{id}/activate"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/automation.v1.Automation/ActivateWorkflow"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *AutomationHTTPClientImpl) CallWebhook(ctx context.Context, in *CallWebhookReq, opts ...http.CallOption) (*CallWebhookReply, error) {
	var out CallWebhookReply
	pattern := "/v1/webhook/{webhookId}"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation("/automation.v1.Automation/CallWebhook"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *AutomationHTTPClientImpl) DeactivateWorkflow(ctx context.Context, in *DeactivateWorkflowReq, opts ...http.CallOption) (*DeactivateWorkflowReply, error) {
	var out DeactivateWorkflowReply
	pattern := "/v1/workflows/{id}/deactivate"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/automation.v1.Automation/DeactivateWorkflow"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *AutomationHTTPClientImpl) DeleteIntegration(ctx context.Context, in *DeleteIntegrationReq, opts ...http.CallOption) (*DeleteIntegrationReply, error) {
	var out DeleteIntegrationReply
	pattern := "/v1/integrations/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/automation.v1.Automation/DeleteIntegration"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *AutomationHTTPClientImpl) DeleteWorkflow(ctx context.Context, in *DeleteWorkflowReq, opts ...http.CallOption) (*DeleteWorkflowReply, error) {
	var out DeleteWorkflowReply
	pattern := "/v1/workflows/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/automation.v1.Automation/DeleteWorkflow"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *AutomationHTTPClientImpl) GetExecution(ctx context.Context, in *GetExecutionReq, opts ...http.CallOption) (*GetExecutionReply, error) {
	var out GetExecutionReply
	pattern := "/v1/executions/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/automation.v1.Automation/GetExecution"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *AutomationHTTPClientImpl) GetExecutions(ctx context.Context, in *GetExecutionsReq, opts ...http.CallOption) (*GetExecutionsReply, error) {
	var out GetExecutionsReply
	pattern := "/v1/executions"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/automation.v1.Automation/GetExecutions"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *AutomationHTTPClientImpl) GetIntegration(ctx context.Context, in *GetIntegrationReq, opts ...http.CallOption) (*GetIntegrationReply, error) {
	var out GetIntegrationReply
	pattern := "/v1/integrations/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/automation.v1.Automation/GetIntegration"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *AutomationHTTPClientImpl) GetIntegrations(ctx context.Context, in *GetIntegrationsReq, opts ...http.CallOption) (*GetIntegrationsReply, error) {
	var out GetIntegrationsReply
	pattern := "/v1/integrations"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/automation.v1.Automation/GetIntegrations"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *AutomationHTTPClientImpl) GetIntegrationsByType(ctx context.Context, in *GetIntegrationsByTypeReq, opts ...http.CallOption) (*GetIntegrationsByTypeReply, error) {
	var out GetIntegrationsByTypeReply
	pattern := "/v1/integrations/filter"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/automation.v1.Automation/GetIntegrationsByType"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *AutomationHTTPClientImpl) GetTodo(ctx context.Context, in *GetTodoReq, opts ...http.CallOption) (*GetTodoReply, error) {
	var out GetTodoReply
	pattern := "/v1/todo/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/automation.v1.Automation/GetTodo"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *AutomationHTTPClientImpl) GetTodosByExecution(ctx context.Context, in *GetTodosByExecutionReq, opts ...http.CallOption) (*GetTodosByExecutionReply, error) {
	var out GetTodosByExecutionReply
	pattern := "/v1/todo/byExecution"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/automation.v1.Automation/GetTodosByExecution"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *AutomationHTTPClientImpl) GetWorkflow(ctx context.Context, in *GetWorkflowReq, opts ...http.CallOption) (*GetWorkflowReply, error) {
	var out GetWorkflowReply
	pattern := "/v1/workflows/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/automation.v1.Automation/GetWorkflow"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *AutomationHTTPClientImpl) GetWorkflowsByApp(ctx context.Context, in *GetWorkflowsByAppReq, opts ...http.CallOption) (*GetWorkflowsByAppReply, error) {
	var out GetWorkflowsByAppReply
	pattern := "/v1/workflows"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/automation.v1.Automation/GetWorkflowsByApp"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *AutomationHTTPClientImpl) SaveIntegration(ctx context.Context, in *SaveIntegrationReq, opts ...http.CallOption) (*SaveIntegrationReply, error) {
	var out SaveIntegrationReply
	pattern := "/v1/integrations"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation("/automation.v1.Automation/SaveIntegration"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *AutomationHTTPClientImpl) SaveWorkflow(ctx context.Context, in *SaveWorkflowReq, opts ...http.CallOption) (*SaveWorkflowReply, error) {
	var out SaveWorkflowReply
	pattern := "/v1/workflows"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation("/automation.v1.Automation/SaveWorkflow"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *AutomationHTTPClientImpl) SaveWorkflowMeta(ctx context.Context, in *SaveWorkflowMetaReq, opts ...http.CallOption) (*SaveWorkflowMetaReply, error) {
	var out SaveWorkflowMetaReply
	pattern := "/v1/workflows/meta"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation("/automation.v1.Automation/SaveWorkflowMeta"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *AutomationHTTPClientImpl) TodoFilter(ctx context.Context, in *TodoFilterReq, opts ...http.CallOption) (*TodoFilterReply, error) {
	var out TodoFilterReply
	pattern := "/v1/todo/filter"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/automation.v1.Automation/TodoFilter"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *AutomationHTTPClientImpl) TodoStat(ctx context.Context, in *TodoStatReq, opts ...http.CallOption) (*TodoStatReply, error) {
	var out TodoStatReply
	pattern := "/v1/todo/stat"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/automation.v1.Automation/TodoStat"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}
