// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.12
// source: automation.proto

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// AutomationClient is the client API for Automation service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AutomationClient interface {
	// 查询工作流列表（APP）
	GetWorkflowsByApp(ctx context.Context, in *GetWorkflowsByAppReq, opts ...grpc.CallOption) (*GetWorkflowsByAppReply, error)
	// 查询单个工作流
	GetWorkflow(ctx context.Context, in *GetWorkflowReq, opts ...grpc.CallOption) (*GetWorkflowReply, error)
	// 保存工作流概要信息
	SaveWorkflowMeta(ctx context.Context, in *SaveWorkflowMetaReq, opts ...grpc.CallOption) (*SaveWorkflowMetaReply, error)
	// 保存工作流
	SaveWorkflow(ctx context.Context, in *SaveWorkflowReq, opts ...grpc.CallOption) (*SaveWorkflowReply, error)
	// 删除工作流
	DeleteWorkflow(ctx context.Context, in *DeleteWorkflowReq, opts ...grpc.CallOption) (*DeleteWorkflowReply, error)
	// 激活工作流（启用）
	ActivateWorkflow(ctx context.Context, in *ActivateWorkflowReq, opts ...grpc.CallOption) (*ActivateWorkflowReply, error)
	// 去激活工作流（关闭）
	DeactivateWorkflow(ctx context.Context, in *DeactivateWorkflowReq, opts ...grpc.CallOption) (*DeactivateWorkflowReply, error)
	// 获取执行结果
	GetExecutions(ctx context.Context, in *GetExecutionsReq, opts ...grpc.CallOption) (*GetExecutionsReply, error)
	// 获取执行结果
	GetExecution(ctx context.Context, in *GetExecutionReq, opts ...grpc.CallOption) (*GetExecutionReply, error)
	// Webhook调用
	CallWebhook(ctx context.Context, in *CallWebhookReq, opts ...grpc.CallOption) (*CallWebhookReply, error)
	// 创建/更新集成
	SaveIntegration(ctx context.Context, in *SaveIntegrationReq, opts ...grpc.CallOption) (*SaveIntegrationReply, error)
	// 查询集成列表
	GetIntegrations(ctx context.Context, in *GetIntegrationsReq, opts ...grpc.CallOption) (*GetIntegrationsReply, error)
	// 查询集成列表（限制类型）
	GetIntegrationsByType(ctx context.Context, in *GetIntegrationsByTypeReq, opts ...grpc.CallOption) (*GetIntegrationsByTypeReply, error)
	// 查询单个集成
	GetIntegration(ctx context.Context, in *GetIntegrationReq, opts ...grpc.CallOption) (*GetIntegrationReply, error)
	// 删除集成
	DeleteIntegration(ctx context.Context, in *DeleteIntegrationReq, opts ...grpc.CallOption) (*DeleteIntegrationReply, error)
	// 获取任务流程待办列表
	GetTodosByExecution(ctx context.Context, in *GetTodosByExecutionReq, opts ...grpc.CallOption) (*GetTodosByExecutionReply, error)
	// 待办列表统计
	TodoStat(ctx context.Context, in *TodoStatReq, opts ...grpc.CallOption) (*TodoStatReply, error)
	// 筛选待办列表
	TodoFilter(ctx context.Context, in *TodoFilterReq, opts ...grpc.CallOption) (*TodoFilterReply, error)
	// 获取单条待办信息
	GetTodo(ctx context.Context, in *GetTodoReq, opts ...grpc.CallOption) (*GetTodoReply, error)
}

type automationClient struct {
	cc grpc.ClientConnInterface
}

func NewAutomationClient(cc grpc.ClientConnInterface) AutomationClient {
	return &automationClient{cc}
}

func (c *automationClient) GetWorkflowsByApp(ctx context.Context, in *GetWorkflowsByAppReq, opts ...grpc.CallOption) (*GetWorkflowsByAppReply, error) {
	out := new(GetWorkflowsByAppReply)
	err := c.cc.Invoke(ctx, "/automation.v1.Automation/GetWorkflowsByApp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *automationClient) GetWorkflow(ctx context.Context, in *GetWorkflowReq, opts ...grpc.CallOption) (*GetWorkflowReply, error) {
	out := new(GetWorkflowReply)
	err := c.cc.Invoke(ctx, "/automation.v1.Automation/GetWorkflow", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *automationClient) SaveWorkflowMeta(ctx context.Context, in *SaveWorkflowMetaReq, opts ...grpc.CallOption) (*SaveWorkflowMetaReply, error) {
	out := new(SaveWorkflowMetaReply)
	err := c.cc.Invoke(ctx, "/automation.v1.Automation/SaveWorkflowMeta", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *automationClient) SaveWorkflow(ctx context.Context, in *SaveWorkflowReq, opts ...grpc.CallOption) (*SaveWorkflowReply, error) {
	out := new(SaveWorkflowReply)
	err := c.cc.Invoke(ctx, "/automation.v1.Automation/SaveWorkflow", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *automationClient) DeleteWorkflow(ctx context.Context, in *DeleteWorkflowReq, opts ...grpc.CallOption) (*DeleteWorkflowReply, error) {
	out := new(DeleteWorkflowReply)
	err := c.cc.Invoke(ctx, "/automation.v1.Automation/DeleteWorkflow", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *automationClient) ActivateWorkflow(ctx context.Context, in *ActivateWorkflowReq, opts ...grpc.CallOption) (*ActivateWorkflowReply, error) {
	out := new(ActivateWorkflowReply)
	err := c.cc.Invoke(ctx, "/automation.v1.Automation/ActivateWorkflow", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *automationClient) DeactivateWorkflow(ctx context.Context, in *DeactivateWorkflowReq, opts ...grpc.CallOption) (*DeactivateWorkflowReply, error) {
	out := new(DeactivateWorkflowReply)
	err := c.cc.Invoke(ctx, "/automation.v1.Automation/DeactivateWorkflow", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *automationClient) GetExecutions(ctx context.Context, in *GetExecutionsReq, opts ...grpc.CallOption) (*GetExecutionsReply, error) {
	out := new(GetExecutionsReply)
	err := c.cc.Invoke(ctx, "/automation.v1.Automation/GetExecutions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *automationClient) GetExecution(ctx context.Context, in *GetExecutionReq, opts ...grpc.CallOption) (*GetExecutionReply, error) {
	out := new(GetExecutionReply)
	err := c.cc.Invoke(ctx, "/automation.v1.Automation/GetExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *automationClient) CallWebhook(ctx context.Context, in *CallWebhookReq, opts ...grpc.CallOption) (*CallWebhookReply, error) {
	out := new(CallWebhookReply)
	err := c.cc.Invoke(ctx, "/automation.v1.Automation/CallWebhook", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *automationClient) SaveIntegration(ctx context.Context, in *SaveIntegrationReq, opts ...grpc.CallOption) (*SaveIntegrationReply, error) {
	out := new(SaveIntegrationReply)
	err := c.cc.Invoke(ctx, "/automation.v1.Automation/SaveIntegration", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *automationClient) GetIntegrations(ctx context.Context, in *GetIntegrationsReq, opts ...grpc.CallOption) (*GetIntegrationsReply, error) {
	out := new(GetIntegrationsReply)
	err := c.cc.Invoke(ctx, "/automation.v1.Automation/GetIntegrations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *automationClient) GetIntegrationsByType(ctx context.Context, in *GetIntegrationsByTypeReq, opts ...grpc.CallOption) (*GetIntegrationsByTypeReply, error) {
	out := new(GetIntegrationsByTypeReply)
	err := c.cc.Invoke(ctx, "/automation.v1.Automation/GetIntegrationsByType", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *automationClient) GetIntegration(ctx context.Context, in *GetIntegrationReq, opts ...grpc.CallOption) (*GetIntegrationReply, error) {
	out := new(GetIntegrationReply)
	err := c.cc.Invoke(ctx, "/automation.v1.Automation/GetIntegration", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *automationClient) DeleteIntegration(ctx context.Context, in *DeleteIntegrationReq, opts ...grpc.CallOption) (*DeleteIntegrationReply, error) {
	out := new(DeleteIntegrationReply)
	err := c.cc.Invoke(ctx, "/automation.v1.Automation/DeleteIntegration", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *automationClient) GetTodosByExecution(ctx context.Context, in *GetTodosByExecutionReq, opts ...grpc.CallOption) (*GetTodosByExecutionReply, error) {
	out := new(GetTodosByExecutionReply)
	err := c.cc.Invoke(ctx, "/automation.v1.Automation/GetTodosByExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *automationClient) TodoStat(ctx context.Context, in *TodoStatReq, opts ...grpc.CallOption) (*TodoStatReply, error) {
	out := new(TodoStatReply)
	err := c.cc.Invoke(ctx, "/automation.v1.Automation/TodoStat", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *automationClient) TodoFilter(ctx context.Context, in *TodoFilterReq, opts ...grpc.CallOption) (*TodoFilterReply, error) {
	out := new(TodoFilterReply)
	err := c.cc.Invoke(ctx, "/automation.v1.Automation/TodoFilter", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *automationClient) GetTodo(ctx context.Context, in *GetTodoReq, opts ...grpc.CallOption) (*GetTodoReply, error) {
	out := new(GetTodoReply)
	err := c.cc.Invoke(ctx, "/automation.v1.Automation/GetTodo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AutomationServer is the server API for Automation service.
// All implementations must embed UnimplementedAutomationServer
// for forward compatibility
type AutomationServer interface {
	// 查询工作流列表（APP）
	GetWorkflowsByApp(context.Context, *GetWorkflowsByAppReq) (*GetWorkflowsByAppReply, error)
	// 查询单个工作流
	GetWorkflow(context.Context, *GetWorkflowReq) (*GetWorkflowReply, error)
	// 保存工作流概要信息
	SaveWorkflowMeta(context.Context, *SaveWorkflowMetaReq) (*SaveWorkflowMetaReply, error)
	// 保存工作流
	SaveWorkflow(context.Context, *SaveWorkflowReq) (*SaveWorkflowReply, error)
	// 删除工作流
	DeleteWorkflow(context.Context, *DeleteWorkflowReq) (*DeleteWorkflowReply, error)
	// 激活工作流（启用）
	ActivateWorkflow(context.Context, *ActivateWorkflowReq) (*ActivateWorkflowReply, error)
	// 去激活工作流（关闭）
	DeactivateWorkflow(context.Context, *DeactivateWorkflowReq) (*DeactivateWorkflowReply, error)
	// 获取执行结果
	GetExecutions(context.Context, *GetExecutionsReq) (*GetExecutionsReply, error)
	// 获取执行结果
	GetExecution(context.Context, *GetExecutionReq) (*GetExecutionReply, error)
	// Webhook调用
	CallWebhook(context.Context, *CallWebhookReq) (*CallWebhookReply, error)
	// 创建/更新集成
	SaveIntegration(context.Context, *SaveIntegrationReq) (*SaveIntegrationReply, error)
	// 查询集成列表
	GetIntegrations(context.Context, *GetIntegrationsReq) (*GetIntegrationsReply, error)
	// 查询集成列表（限制类型）
	GetIntegrationsByType(context.Context, *GetIntegrationsByTypeReq) (*GetIntegrationsByTypeReply, error)
	// 查询单个集成
	GetIntegration(context.Context, *GetIntegrationReq) (*GetIntegrationReply, error)
	// 删除集成
	DeleteIntegration(context.Context, *DeleteIntegrationReq) (*DeleteIntegrationReply, error)
	// 获取任务流程待办列表
	GetTodosByExecution(context.Context, *GetTodosByExecutionReq) (*GetTodosByExecutionReply, error)
	// 待办列表统计
	TodoStat(context.Context, *TodoStatReq) (*TodoStatReply, error)
	// 筛选待办列表
	TodoFilter(context.Context, *TodoFilterReq) (*TodoFilterReply, error)
	// 获取单条待办信息
	GetTodo(context.Context, *GetTodoReq) (*GetTodoReply, error)
	mustEmbedUnimplementedAutomationServer()
}

// UnimplementedAutomationServer must be embedded to have forward compatible implementations.
type UnimplementedAutomationServer struct {
}

func (UnimplementedAutomationServer) GetWorkflowsByApp(context.Context, *GetWorkflowsByAppReq) (*GetWorkflowsByAppReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWorkflowsByApp not implemented")
}
func (UnimplementedAutomationServer) GetWorkflow(context.Context, *GetWorkflowReq) (*GetWorkflowReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWorkflow not implemented")
}
func (UnimplementedAutomationServer) SaveWorkflowMeta(context.Context, *SaveWorkflowMetaReq) (*SaveWorkflowMetaReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveWorkflowMeta not implemented")
}
func (UnimplementedAutomationServer) SaveWorkflow(context.Context, *SaveWorkflowReq) (*SaveWorkflowReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveWorkflow not implemented")
}
func (UnimplementedAutomationServer) DeleteWorkflow(context.Context, *DeleteWorkflowReq) (*DeleteWorkflowReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteWorkflow not implemented")
}
func (UnimplementedAutomationServer) ActivateWorkflow(context.Context, *ActivateWorkflowReq) (*ActivateWorkflowReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ActivateWorkflow not implemented")
}
func (UnimplementedAutomationServer) DeactivateWorkflow(context.Context, *DeactivateWorkflowReq) (*DeactivateWorkflowReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeactivateWorkflow not implemented")
}
func (UnimplementedAutomationServer) GetExecutions(context.Context, *GetExecutionsReq) (*GetExecutionsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetExecutions not implemented")
}
func (UnimplementedAutomationServer) GetExecution(context.Context, *GetExecutionReq) (*GetExecutionReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetExecution not implemented")
}
func (UnimplementedAutomationServer) CallWebhook(context.Context, *CallWebhookReq) (*CallWebhookReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CallWebhook not implemented")
}
func (UnimplementedAutomationServer) SaveIntegration(context.Context, *SaveIntegrationReq) (*SaveIntegrationReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveIntegration not implemented")
}
func (UnimplementedAutomationServer) GetIntegrations(context.Context, *GetIntegrationsReq) (*GetIntegrationsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIntegrations not implemented")
}
func (UnimplementedAutomationServer) GetIntegrationsByType(context.Context, *GetIntegrationsByTypeReq) (*GetIntegrationsByTypeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIntegrationsByType not implemented")
}
func (UnimplementedAutomationServer) GetIntegration(context.Context, *GetIntegrationReq) (*GetIntegrationReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIntegration not implemented")
}
func (UnimplementedAutomationServer) DeleteIntegration(context.Context, *DeleteIntegrationReq) (*DeleteIntegrationReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteIntegration not implemented")
}
func (UnimplementedAutomationServer) GetTodosByExecution(context.Context, *GetTodosByExecutionReq) (*GetTodosByExecutionReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTodosByExecution not implemented")
}
func (UnimplementedAutomationServer) TodoStat(context.Context, *TodoStatReq) (*TodoStatReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TodoStat not implemented")
}
func (UnimplementedAutomationServer) TodoFilter(context.Context, *TodoFilterReq) (*TodoFilterReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TodoFilter not implemented")
}
func (UnimplementedAutomationServer) GetTodo(context.Context, *GetTodoReq) (*GetTodoReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTodo not implemented")
}
func (UnimplementedAutomationServer) mustEmbedUnimplementedAutomationServer() {}

// UnsafeAutomationServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AutomationServer will
// result in compilation errors.
type UnsafeAutomationServer interface {
	mustEmbedUnimplementedAutomationServer()
}

func RegisterAutomationServer(s grpc.ServiceRegistrar, srv AutomationServer) {
	s.RegisterService(&Automation_ServiceDesc, srv)
}

func _Automation_GetWorkflowsByApp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWorkflowsByAppReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutomationServer).GetWorkflowsByApp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/automation.v1.Automation/GetWorkflowsByApp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutomationServer).GetWorkflowsByApp(ctx, req.(*GetWorkflowsByAppReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Automation_GetWorkflow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWorkflowReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutomationServer).GetWorkflow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/automation.v1.Automation/GetWorkflow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutomationServer).GetWorkflow(ctx, req.(*GetWorkflowReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Automation_SaveWorkflowMeta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveWorkflowMetaReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutomationServer).SaveWorkflowMeta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/automation.v1.Automation/SaveWorkflowMeta",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutomationServer).SaveWorkflowMeta(ctx, req.(*SaveWorkflowMetaReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Automation_SaveWorkflow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveWorkflowReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutomationServer).SaveWorkflow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/automation.v1.Automation/SaveWorkflow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutomationServer).SaveWorkflow(ctx, req.(*SaveWorkflowReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Automation_DeleteWorkflow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteWorkflowReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutomationServer).DeleteWorkflow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/automation.v1.Automation/DeleteWorkflow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutomationServer).DeleteWorkflow(ctx, req.(*DeleteWorkflowReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Automation_ActivateWorkflow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActivateWorkflowReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutomationServer).ActivateWorkflow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/automation.v1.Automation/ActivateWorkflow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutomationServer).ActivateWorkflow(ctx, req.(*ActivateWorkflowReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Automation_DeactivateWorkflow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeactivateWorkflowReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutomationServer).DeactivateWorkflow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/automation.v1.Automation/DeactivateWorkflow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutomationServer).DeactivateWorkflow(ctx, req.(*DeactivateWorkflowReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Automation_GetExecutions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetExecutionsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutomationServer).GetExecutions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/automation.v1.Automation/GetExecutions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutomationServer).GetExecutions(ctx, req.(*GetExecutionsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Automation_GetExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetExecutionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutomationServer).GetExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/automation.v1.Automation/GetExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutomationServer).GetExecution(ctx, req.(*GetExecutionReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Automation_CallWebhook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CallWebhookReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutomationServer).CallWebhook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/automation.v1.Automation/CallWebhook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutomationServer).CallWebhook(ctx, req.(*CallWebhookReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Automation_SaveIntegration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveIntegrationReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutomationServer).SaveIntegration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/automation.v1.Automation/SaveIntegration",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutomationServer).SaveIntegration(ctx, req.(*SaveIntegrationReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Automation_GetIntegrations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIntegrationsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutomationServer).GetIntegrations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/automation.v1.Automation/GetIntegrations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutomationServer).GetIntegrations(ctx, req.(*GetIntegrationsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Automation_GetIntegrationsByType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIntegrationsByTypeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutomationServer).GetIntegrationsByType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/automation.v1.Automation/GetIntegrationsByType",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutomationServer).GetIntegrationsByType(ctx, req.(*GetIntegrationsByTypeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Automation_GetIntegration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIntegrationReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutomationServer).GetIntegration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/automation.v1.Automation/GetIntegration",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutomationServer).GetIntegration(ctx, req.(*GetIntegrationReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Automation_DeleteIntegration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteIntegrationReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutomationServer).DeleteIntegration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/automation.v1.Automation/DeleteIntegration",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutomationServer).DeleteIntegration(ctx, req.(*DeleteIntegrationReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Automation_GetTodosByExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTodosByExecutionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutomationServer).GetTodosByExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/automation.v1.Automation/GetTodosByExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutomationServer).GetTodosByExecution(ctx, req.(*GetTodosByExecutionReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Automation_TodoStat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TodoStatReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutomationServer).TodoStat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/automation.v1.Automation/TodoStat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutomationServer).TodoStat(ctx, req.(*TodoStatReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Automation_TodoFilter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TodoFilterReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutomationServer).TodoFilter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/automation.v1.Automation/TodoFilter",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutomationServer).TodoFilter(ctx, req.(*TodoFilterReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Automation_GetTodo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTodoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutomationServer).GetTodo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/automation.v1.Automation/GetTodo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutomationServer).GetTodo(ctx, req.(*GetTodoReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Automation_ServiceDesc is the grpc.ServiceDesc for Automation service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Automation_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "automation.v1.Automation",
	HandlerType: (*AutomationServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetWorkflowsByApp",
			Handler:    _Automation_GetWorkflowsByApp_Handler,
		},
		{
			MethodName: "GetWorkflow",
			Handler:    _Automation_GetWorkflow_Handler,
		},
		{
			MethodName: "SaveWorkflowMeta",
			Handler:    _Automation_SaveWorkflowMeta_Handler,
		},
		{
			MethodName: "SaveWorkflow",
			Handler:    _Automation_SaveWorkflow_Handler,
		},
		{
			MethodName: "DeleteWorkflow",
			Handler:    _Automation_DeleteWorkflow_Handler,
		},
		{
			MethodName: "ActivateWorkflow",
			Handler:    _Automation_ActivateWorkflow_Handler,
		},
		{
			MethodName: "DeactivateWorkflow",
			Handler:    _Automation_DeactivateWorkflow_Handler,
		},
		{
			MethodName: "GetExecutions",
			Handler:    _Automation_GetExecutions_Handler,
		},
		{
			MethodName: "GetExecution",
			Handler:    _Automation_GetExecution_Handler,
		},
		{
			MethodName: "CallWebhook",
			Handler:    _Automation_CallWebhook_Handler,
		},
		{
			MethodName: "SaveIntegration",
			Handler:    _Automation_SaveIntegration_Handler,
		},
		{
			MethodName: "GetIntegrations",
			Handler:    _Automation_GetIntegrations_Handler,
		},
		{
			MethodName: "GetIntegrationsByType",
			Handler:    _Automation_GetIntegrationsByType_Handler,
		},
		{
			MethodName: "GetIntegration",
			Handler:    _Automation_GetIntegration_Handler,
		},
		{
			MethodName: "DeleteIntegration",
			Handler:    _Automation_DeleteIntegration_Handler,
		},
		{
			MethodName: "GetTodosByExecution",
			Handler:    _Automation_GetTodosByExecution_Handler,
		},
		{
			MethodName: "TodoStat",
			Handler:    _Automation_TodoStat_Handler,
		},
		{
			MethodName: "TodoFilter",
			Handler:    _Automation_TodoFilter_Handler,
		},
		{
			MethodName: "GetTodo",
			Handler:    _Automation_GetTodo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "automation.proto",
}
