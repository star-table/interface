// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// protoc-gen-go-http v2.1.4

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

type RecycleHTTPServer interface {
	ListRecycle(context.Context, *ListRecycleRequest) (*ListRecycleReply, error)
	Recover(context.Context, *RecoverRequest) (*RecoverReply, error)
	RecycleDocument(context.Context, *RecycleDocumentRequest) (*RecycleDocumentReply, error)
}

func RegisterRecycleHTTPServer(s *http.Server, srv RecycleHTTPServer) {
	r := s.Route("/")
	r.POST("/v1/document/recycle", _Recycle_RecycleDocument0_HTTP_Handler(srv))
	r.POST("/v1/recycle/recover", _Recycle_Recover0_HTTP_Handler(srv))
	r.POST("/v1/recycle/list", _Recycle_ListRecycle0_HTTP_Handler(srv))
}

func _Recycle_RecycleDocument0_HTTP_Handler(srv RecycleHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in RecycleDocumentRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/knowledge.v1.Recycle/RecycleDocument")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.RecycleDocument(ctx, req.(*RecycleDocumentRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*RecycleDocumentReply)
		return ctx.Result(200, reply)
	}
}

func _Recycle_Recover0_HTTP_Handler(srv RecycleHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in RecoverRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/knowledge.v1.Recycle/Recover")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.Recover(ctx, req.(*RecoverRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*RecoverReply)
		return ctx.Result(200, reply)
	}
}

func _Recycle_ListRecycle0_HTTP_Handler(srv RecycleHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListRecycleRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/knowledge.v1.Recycle/ListRecycle")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListRecycle(ctx, req.(*ListRecycleRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListRecycleReply)
		return ctx.Result(200, reply)
	}
}

type RecycleHTTPClient interface {
	ListRecycle(ctx context.Context, req *ListRecycleRequest, opts ...http.CallOption) (rsp *ListRecycleReply, err error)
	Recover(ctx context.Context, req *RecoverRequest, opts ...http.CallOption) (rsp *RecoverReply, err error)
	RecycleDocument(ctx context.Context, req *RecycleDocumentRequest, opts ...http.CallOption) (rsp *RecycleDocumentReply, err error)
}

type RecycleHTTPClientImpl struct {
	cc *http.Client
}

func NewRecycleHTTPClient(client *http.Client) RecycleHTTPClient {
	return &RecycleHTTPClientImpl{client}
}

func (c *RecycleHTTPClientImpl) ListRecycle(ctx context.Context, in *ListRecycleRequest, opts ...http.CallOption) (*ListRecycleReply, error) {
	var out ListRecycleReply
	pattern := "/v1/recycle/list"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation("/knowledge.v1.Recycle/ListRecycle"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *RecycleHTTPClientImpl) Recover(ctx context.Context, in *RecoverRequest, opts ...http.CallOption) (*RecoverReply, error) {
	var out RecoverReply
	pattern := "/v1/recycle/recover"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation("/knowledge.v1.Recycle/Recover"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *RecycleHTTPClientImpl) RecycleDocument(ctx context.Context, in *RecycleDocumentRequest, opts ...http.CallOption) (*RecycleDocumentReply, error) {
	var out RecycleDocumentReply
	pattern := "/v1/document/recycle"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation("/knowledge.v1.Recycle/RecycleDocument"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}
